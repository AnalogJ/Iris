{"ts":1355695652254,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"Monocle.Controls.Contents = function (reader) {\n\n  var API = { constructor: Monocle.Controls.Contents }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    reader: reader\n  }\n\n\n  function createControlElements() {\n    var div = reader.dom.make('div', 'controls_contents_container');\n    contentsForBook(div, reader.getBook());\n    return div;\n  }\n\n\n  function contentsForBook(div, book) {\n    while (div.hasChildNodes()) {\n      div.removeChild(div.firstChild);\n    }\n    var list = div.dom.append('ol', 'controls_contents_list');\n\n    var contents = book.properties.contents;\n    for (var i = 0; i < contents.length; ++i) {\n      chapterBuilder(list, contents[i], 0);\n    }\n  }\n\n\n  function chapterBuilder(list, chp, padLvl) {\n    var index = list.childNodes.length;\n    var li = list.dom.append('li', 'controls_contents_chapter', index);\n    var span = li.dom.append(\n      'span',\n      'controls_contents_chapterTitle',\n      index,\n      { html: chp.title }\n    );\n    span.style.paddingLeft = padLvl + \"em\";\n\n    var invoked = function () {\n      p.reader.skipToChapter(chp.src);\n      p.reader.hideControl(API);\n    }\n\n    Monocle.Events.listenForTap(li, invoked, 'controls_contents_chapter_active');\n\n    if (chp.children) {\n      for (var i = 0; i < chp.children.length; ++i) {\n        chapterBuilder(list, chp.children[i], padLvl + 1);\n      }\n    }\n  }\n\n\n  API.createControlElements = createControlElements;\n\n  return API;\n}\n;\nMonocle.Controls.Magnifier = function (reader) {\n\n  var API = { constructor: Monocle.Controls.Magnifier }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    buttons: [],\n    magnified: false\n  }\n\n\n  function initialize() {\n    p.reader = reader;\n  }\n\n\n  function createControlElements(holder) {\n    var btn = holder.dom.make('div', 'controls_magnifier_button');\n    btn.smallA = btn.dom.append('span', 'controls_magnifier_a', { text: 'A' });\n    btn.largeA = btn.dom.append('span', 'controls_magnifier_A', { text: 'A' });\n    p.buttons.push(btn);\n    Monocle.Events.listenForTap(btn, toggleMagnification);\n    return btn;\n  }\n\n\n  function toggleMagnification(evt) {\n    var opacities;\n    p.magnified = !p.magnified;\n    if (p.magnified) {\n      opacities = [0.3, 1];\n      p.reader.formatting.setFontScale(k.MAGNIFICATION, true);\n    } else {\n      opacities = [1, 0.3];\n      p.reader.formatting.setFontScale(null, true);\n    }\n\n    for (var i = 0; i < p.buttons.length; i++) {\n      p.buttons[i].smallA.style.opacity = opacities[0];\n      p.buttons[i].largeA.style.opacity = opacities[1];\n    }\n  }\n\n  API.createControlElements = createControlElements;\n\n  initialize();\n\n  return API;\n}\n\n\nMonocle.Controls.Magnifier.MAGNIFICATION = 1.2;\n// A panel is an invisible column of interactivity. When contact occurs\n// (mousedown, touchstart), the panel expands to the full width of its\n// container, to catch all interaction events and prevent them from hitting\n// other things.\n//\n// Panels are used primarily to provide hit zones for page flipping\n// interactions, but you can do whatever you like with them.\n//\n// After instantiating a panel and adding it to the reader as a control,\n// you can call listenTo() with a hash of methods for any of 'start', 'move'\n// 'end' and 'cancel'.\n//\nMonocle.Controls.Panel = function () {\n\n  var API = { constructor: Monocle.Controls.Panel }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    evtCallbacks: {}\n  }\n\n  function createControlElements(cntr) {\n    p.div = cntr.dom.make('div', k.CLS.panel);\n    p.div.dom.setStyles(k.DEFAULT_STYLES);\n    Monocle.Events.listenForContact(\n      p.div,\n      {\n        'start': start,\n        'move': move,\n        'end': end,\n        'cancel': cancel\n      },\n      { useCapture: false }\n    );\n    return p.div;\n  }\n\n\n  function setDirection(dir) {\n    p.direction = dir;\n  }\n\n\n  function listenTo(evtCallbacks) {\n    p.evtCallbacks = evtCallbacks;\n  }\n\n\n  function deafen() {\n    p.evtCallbacks = {}\n  }\n\n\n  function start(evt) {\n    p.contact = true;\n    evt.m.offsetX += p.div.offsetLeft;\n    evt.m.offsetY += p.div.offsetTop;\n    expand();\n    invoke('start', evt);\n  }\n\n\n  function move(evt) {\n    if (!p.contact) {\n      return;\n    }\n    invoke('move', evt);\n  }\n\n\n  function end(evt) {\n    if (!p.contact) {\n      return;\n    }\n    Monocle.Events.deafenForContact(p.div, p.listeners);\n    contract();\n    p.contact = false;\n    invoke('end', evt);\n  }\n\n\n  function cancel(evt) {\n    if (!p.contact) {\n      return;\n    }\n    Monocle.Events.deafenForContact(p.div, p.listeners);\n    contract();\n    p.contact = false;\n    invoke('cancel', evt);\n  }\n\n\n  function invoke(evtType, evt) {\n    if (p.evtCallbacks[evtType]) {\n      p.evtCallbacks[evtType](p.direction, evt.m.offsetX, evt.m.offsetY, API);\n    }\n    evt.preventDefault();\n  }\n\n\n  function expand() {\n    if (p.expanded) {\n      return;\n    }\n    p.div.dom.addClass(k.CLS.expanded);\n    p.expanded = true;\n  }\n\n\n  function contract(evt) {\n    if (!p.expanded) {\n      return;\n    }\n    p.div.dom.removeClass(k.CLS.expanded);\n    p.expanded = false;\n  }\n\n\n  API.createControlElements = createControlElements;\n  API.listenTo = listenTo;\n  API.deafen = deafen;\n  API.expand = expand;\n  API.contract = contract;\n  API.setDirection = setDirection;\n\n  return API;\n}\n\n\nMonocle.Controls.Panel.CLS = {\n  panel: 'panel',\n  expanded: 'controls_panel_expanded'\n}\nMonocle.Controls.Panel.DEFAULT_STYLES = {\n  position: 'absolute',\n  height: '100%'\n}\n;\nMonocle.Controls.PlaceSaver = function (bookId) {\n\n  var API = { constructor: Monocle.Controls.PlaceSaver }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {}\n\n\n  function initialize() {\n    applyToBook(bookId);\n  }\n\n\n  function assignToReader(reader) {\n    p.reader = reader;\n    p.reader.listen('monocle:turn', savePlaceToCookie);\n  }\n\n\n  function applyToBook(bookId) {\n    p.bkTitle = bookId.toLowerCase().replace(/[^a-z0-9]/g, '');\n    p.prefix = k.COOKIE_NAMESPACE + p.bkTitle + \".\";\n  }\n\n\n  function setCookie(key, value, days) {\n    var expires = \"\";\n    if (days) {\n      var d = new Date();\n      d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));\n      expires = \"; expires=\"+d.toGMTString();\n    }\n    var path = \"; path=/\";\n    document.cookie = p.prefix + key + \"=\" + value + expires + path;\n    return value;\n  }\n\n\n  function getCookie(key) {\n    if (!document.cookie) {\n      return null;\n    }\n    var regex = new RegExp(p.prefix + key + \"=(.+?)(;|$)\");\n    var matches = document.cookie.match(regex);\n    if (matches) {\n      return matches[1];\n    } else {\n      return null;\n    }\n  }\n\n\n  function savePlaceToCookie() {\n    var place = p.reader.getPlace();\n    setCookie(\n      \"component\",\n      encodeURIComponent(place.componentId()),\n      k.COOKIE_EXPIRES_IN_DAYS\n    );\n    setCookie(\n      \"percent\",\n      place.percentageThrough(),\n      k.COOKIE_EXPIRES_IN_DAYS\n    );\n  }\n\n\n  function savedPlace() {\n    var locus = {\n      componentId: getCookie('component'),\n      percent: getCookie('percent')\n    }\n    if (locus.componentId && locus.percent) {\n      locus.componentId = decodeURIComponent(locus.componentId);\n      locus.percent = parseFloat(locus.percent);\n      return locus;\n    } else {\n      return null;\n    }\n  }\n\n\n  function restorePlace() {\n    var locus = savedPlace();\n    if (locus) {\n      p.reader.moveTo(locus);\n    }\n  }\n\n\n  API.assignToReader = assignToReader;\n  API.savedPlace = savedPlace;\n  API.restorePlace = restorePlace;\n\n  initialize();\n\n  return API;\n}\n\nMonocle.Controls.PlaceSaver.COOKIE_NAMESPACE = \"monocle.controls.placesaver.\";\nMonocle.Controls.PlaceSaver.COOKIE_EXPIRES_IN_DAYS = 7; // Set to 0 for session-based expiry.\n;\nMonocle.Controls.Scrubber = function (reader) {\n\n  var API = { constructor: Monocle.Controls.Scrubber }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {}\n\n\n  function initialize() {\n    p.reader = reader;\n    p.reader.listen('monocle:turn', updateNeedles);\n    updateNeedles();\n  }\n\n\n  function pixelToPlace(x, cntr) {\n    if (!p.componentIds) {\n      p.componentIds = p.reader.getBook().properties.componentIds;\n      p.componentWidth = 100 / p.componentIds.length;\n    }\n    var pc = (x / cntr.offsetWidth) * 100;\n    var cmpt = p.componentIds[Math.floor(pc / p.componentWidth)];\n    var cmptPc = ((pc % p.componentWidth) / p.componentWidth);\n    return { componentId: cmpt, percentageThrough: cmptPc };\n  }\n\n\n  function placeToPixel(place, cntr) {\n    if (!p.componentIds) {\n      p.componentIds = p.reader.getBook().properties.componentIds;\n      p.componentWidth = 100 / p.componentIds.length;\n    }\n    var componentIndex = p.componentIds.indexOf(place.componentId());\n    var pc = p.componentWidth * componentIndex;\n    pc += place.percentageThrough() * p.componentWidth;\n    return Math.round((pc / 100) * cntr.offsetWidth);\n  }\n\n\n  function updateNeedles() {\n    if (p.hidden || !p.reader.dom.find(k.CLS.container)) {\n      return;\n    }\n    var place = p.reader.getPlace();\n    var x = placeToPixel(place, p.reader.dom.find(k.CLS.container));\n    var needle, i = 0;\n    for (var i = 0, needle; needle = p.reader.dom.find(k.CLS.needle, i); ++i) {\n      setX(needle, x - needle.offsetWidth / 2);\n      p.reader.dom.find(k.CLS.trail, i).style.width = x + \"px\";\n    }\n  }\n\n\n  function setX(node, x) {\n    var cntr = p.reader.dom.find(k.CLS.container);\n    x = Math.min(cntr.offsetWidth - node.offsetWidth, x);\n    x = Math.max(x, 0);\n    Monocle.Styles.setX(node, x);\n  }\n\n\n  function createControlElements(holder) {\n    var cntr = holder.dom.make('div', k.CLS.container);\n    var track = cntr.dom.append('div', k.CLS.track);\n    var needleTrail = cntr.dom.append('div', k.CLS.trail);\n    var needle = cntr.dom.append('div', k.CLS.needle);\n    var bubble = cntr.dom.append('div', k.CLS.bubble);\n\n    var cntrListeners, bodyListeners;\n\n    var moveEvt = function (evt, x) {\n      evt.preventDefault();\n      x = (typeof x == \"number\") ? x : evt.m.registrantX;\n      var place = pixelToPlace(x, cntr);\n      setX(needle, x - needle.offsetWidth / 2);\n      var book = p.reader.getBook();\n      var chps = book.chaptersForComponent(place.componentId);\n      var cmptIndex = p.componentIds.indexOf(place.componentId);\n      var chp = chps[Math.floor(chps.length * place.percentageThrough)];\n      if (cmptIndex > -1 && book.properties.components[cmptIndex]) {\n        var actualPlace = Monocle.Place.FromPercentageThrough(\n          book.properties.components[cmptIndex],\n          place.percentageThrough\n        );\n        chp = actualPlace.chapterInfo() || chp;\n      }\n\n      if (chp) {\n        bubble.innerHTML = chp.title;\n      }\n      setX(bubble, x - bubble.offsetWidth / 2);\n\n      p.lastX = x;\n      return place;\n    }\n\n    var endEvt = function (evt) {\n      var place = moveEvt(evt, p.lastX);\n      p.reader.moveTo({\n        percent: place.percentageThrough,\n        componentId: place.componentId\n      });\n      Monocle.Events.deafenForContact(cntr, cntrListeners);\n      Monocle.Events.deafenForContact(document.body, bodyListeners);\n      bubble.style.display = \"none\";\n    }\n\n    var startFn = function (evt) {\n      bubble.style.display = \"block\";\n      moveEvt(evt);\n      cntrListeners = Monocle.Events.listenForContact(\n        cntr,\n        { move: moveEvt }\n      );\n      bodyListeners = Monocle.Events.listenForContact(\n        document.body,\n        { end: endEvt }\n      );\n    }\n\n    Monocle.Events.listenForContact(cntr, { start: startFn });\n\n    return cntr;\n  }\n\n\n  API.createControlElements = createControlElements;\n  API.updateNeedles = updateNeedles;\n\n  initialize();\n\n  return API;\n}\n\nMonocle.Controls.Scrubber.CLS = {\n  container: 'controls_scrubber_container',\n  track: 'controls_scrubber_track',\n  needle: 'controls_scrubber_needle',\n  trail: 'controls_scrubber_trail',\n  bubble: 'controls_scrubber_bubble'\n}\n;\nMonocle.Controls.Spinner = function (reader) {\n\n  var API = { constructor: Monocle.Controls.Spinner }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    reader: reader,\n    divs: [],\n    spinCount: 0,\n    repeaters: {},\n    showForPages: []\n  }\n\n\n  function createControlElements(cntr) {\n    var anim = cntr.dom.make('div', 'controls_spinner_anim');\n    p.divs.push(anim);\n    return anim;\n  }\n\n\n  function registerSpinEvt(startEvtType, stopEvtType) {\n    var label = startEvtType;\n    p.reader.listen(startEvtType, function (evt) { spin(label, evt) });\n    p.reader.listen(stopEvtType, function (evt) { spun(label, evt) });\n  }\n\n\n  // Registers spin/spun event handlers for certain time-consuming events.\n  //\n  function listenForUsualDelays() {\n    registerSpinEvt('monocle:componentloading', 'monocle:componentloaded');\n    registerSpinEvt('monocle:componentchanging', 'monocle:componentchange');\n    registerSpinEvt('monocle:resizing', 'monocle:resize');\n    registerSpinEvt('monocle:jumping', 'monocle:jump');\n    registerSpinEvt('monocle:recalculating', 'monocle:recalculated');\n  }\n\n\n  // Displays the spinner. Both arguments are optional.\n  //\n  function spin(label, evt) {\n    label = label || k.GENERIC_LABEL;\n    //console.log('Spinning on ' + (evt ? evt.type : label));\n    p.repeaters[label] = true;\n    p.reader.showControl(API);\n\n    // If the delay is on a page other than the page we've been assigned to,\n    // don't show the animation. p.global ensures that if an event affects\n    // all pages, the animation is always shown, even if other events in this\n    // spin cycle are page-specific.\n    var page = evt && evt.m && evt.m.page ? evt.m.page : null;\n    if (!page) { p.global = true; }\n    for (var i = 0; i < p.divs.length; ++i) {\n      var owner = p.divs[i].parentNode.parentNode;\n      if (page == owner) { p.showForPages.push(page); }\n      var show = p.global || p.showForPages.indexOf(page) >= 0;\n      p.divs[i].style.display = show ? 'block' : 'none';\n    }\n  }\n\n\n  // Stops displaying the spinner. Both arguments are optional.\n  //\n  function spun(label, evt) {\n    label = label || k.GENERIC_LABEL;\n    //console.log('Spun on ' + (evt ? evt.type : label));\n    p.repeaters[label] = false;\n    for (var l in p.repeaters) {\n      if (p.repeaters[l]) { return; }\n    }\n    p.global = false;\n    p.showForPages = [];\n    p.reader.hideControl(API);\n  }\n\n\n  API.createControlElements = createControlElements;\n  API.listenForUsualDelays = listenForUsualDelays;\n  API.spin = spin;\n  API.spun = spun;\n\n  return API;\n}\n\nMonocle.Controls.Spinner.GENERIC_LABEL = \"generic\";\nMonocle.Controls.Stencil = function (reader, behaviorClasses) {\n\n  var API = { constructor: Monocle.Controls.Stencil }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    reader: reader,\n    behaviors: [],\n    components: {},\n    masks: []\n  }\n\n\n  // Create the stencil container and listen for draw/update events.\n  //\n  function createControlElements(holder) {\n    behaviorClasses = behaviorClasses || k.DEFAULT_BEHAVIORS;\n    for (var i = 0, ii = behaviorClasses.length; i < ii; ++i) {\n      addBehavior(behaviorClasses[i]);\n    }\n    p.container = holder.dom.make('div', k.CLS.container);\n    p.reader.listen('monocle:turning', hide);\n    p.reader.listen('monocle:turn:cancel', show);\n    p.reader.listen('monocle:turn', update);\n    p.reader.listen('monocle:stylesheetchange', update);\n    p.reader.listen('monocle:resize', update);\n    update();\n    return p.container;\n  }\n\n\n  // Pass this method an object that responds to 'findElements(doc)' with\n  // an array of DOM elements for that document, and to 'fitMask(elem, mask)'.\n  //\n  // After you have added all your behaviors this way, you would typically\n  // call update() to make them take effect immediately.\n  //\n  function addBehavior(bhvrClass) {\n    var bhvr = new bhvrClass(API);\n    if (typeof bhvr.findElements != 'function') {\n      console.warn('Missing \"findElements\" method for behavior: %o', bhvr);\n    }\n    if (typeof bhvr.fitMask != 'function') {\n      console.warn('Missing \"fitMask\" method for behavior: %o', bhvr);\n    }\n    p.behaviors.push(bhvr);\n  }\n\n\n  // Resets any pre-calculated rectangles for the active component,\n  // recalculates them, and forces masks to be \"drawn\" (moved into the new\n  // rectangular locations).\n  //\n  function update() {\n    var visPages = p.reader.visiblePages();\n    if (!visPages || !visPages.length) { return; }\n    var pageDiv = visPages[0];\n    var cmptId = pageComponentId(pageDiv);\n    if (!cmptId) { return; }\n    p.components[cmptId] = null;\n    calculateRectangles(pageDiv);\n    draw();\n  }\n\n\n  function hide() {\n    p.container.style.display = 'none';\n  }\n\n\n  function show() {\n    p.container.style.display = 'block';\n  }\n\n\n  // Removes any existing masks.\n  function clear() {\n    while (p.container.childNodes.length) {\n      p.container.removeChild(p.container.lastChild);\n    }\n  }\n\n\n  // Aligns the stencil container to the shape of the page, then moves the\n  // masks to sit above any currently visible rectangles.\n  //\n  function draw() {\n    var pageDiv = p.reader.visiblePages()[0];\n    var cmptId = pageComponentId(pageDiv);\n    if (!p.components[cmptId]) {\n      return;\n    }\n\n    // Position the container.\n    alignToComponent(pageDiv);\n\n    // Clear old masks.\n    clear();\n\n    // Layout the masks.\n    if (!p.disabled) {\n      show();\n      var rects = p.components[cmptId];\n      if (rects && rects.length) {\n        layoutRectangles(pageDiv, rects);\n      }\n    }\n  }\n\n\n  // Iterate over all the <a> elements in the active component, and\n  // create an array of rectangular points corresponding to their positions.\n  //\n  function calculateRectangles(pageDiv) {\n    var cmptId = pageComponentId(pageDiv);\n    if (!p.components[cmptId]) {\n      p.components[cmptId] = [];\n    } else {\n      return;\n    }\n\n    var doc = pageDiv.m.activeFrame.contentDocument;\n    var offset = getOffset(pageDiv);\n\n    for (var b = 0, bb = p.behaviors.length; b < bb; ++b) {\n      var bhvr = p.behaviors[b];\n      var elems = bhvr.findElements(doc);\n      for (var i = 0; i < elems.length; ++i) {\n        var elem = elems[i];\n        if (elem.getClientRects) {\n          var r = elem.getClientRects();\n          for (var j = 0; j < r.length; j++) {\n            p.components[cmptId].push({\n              element: elem,\n              behavior: bhvr,\n              left: Math.ceil(r[j].left + offset.l),\n              top: Math.ceil(r[j].top),\n              width: Math.floor(r[j].width),\n              height: Math.floor(r[j].height)\n            });\n          }\n        }\n      }\n    }\n\n    return p.components[cmptId];\n  }\n\n\n  // Update location of visible rectangles - creating as required.\n  //\n  function layoutRectangles(pageDiv, rects) {\n    var offset = getOffset(pageDiv);\n    var visRects = [];\n    for (var i = 0; i < rects.length; ++i) {\n      if (rectVisible(rects[i], offset.l, offset.l + offset.w)) {\n        visRects.push(rects[i]);\n      }\n    }\n\n    for (i = 0; i < visRects.length; ++i) {\n      var r = visRects[i];\n      var cr = {\n        left: r.left - offset.l,\n        top: r.top,\n        width: r.width,\n        height: r.height\n      };\n      var mask = createMask(r.element, r.behavior);\n      mask.dom.setStyles({\n        display: 'block',\n        left: cr.left+\"px\",\n        top: cr.top+\"px\",\n        width: cr.width+\"px\",\n        height: cr.height+\"px\",\n        position: 'absolute'\n      });\n      mask.stencilRect = cr;\n    }\n  }\n\n\n  // Find the offset position in pixels from the left of the current page.\n  //\n  function getOffset(pageDiv) {\n    return {\n      l: pageDiv.m.offset || 0,\n      w: pageDiv.m.dimensions.properties.width\n    };\n  }\n\n\n  // Is this area presently on the screen?\n  //\n  function rectVisible(rect, l, r) {\n    return rect.left >= l && rect.left < r;\n  }\n\n\n  // Returns the active component id for the given page, or the current\n  // page if no argument passed in.\n  //\n  function pageComponentId(pageDiv) {\n    pageDiv = pageDiv || p.reader.visiblePages()[0];\n    if (!pageDiv.m.activeFrame.m.component) { return; }\n    return pageDiv.m.activeFrame.m.component.properties.id;\n  }\n\n\n  // Positions the stencil container over the active frame.\n  //\n  function alignToComponent(pageDiv) {\n    cmpt = pageDiv.m.activeFrame.parentNode;\n    p.container.dom.setStyles({\n      left: cmpt.offsetLeft+\"px\",\n      top: cmpt.offsetTop+\"px\"\n    });\n  }\n\n\n  function createMask(element, bhvr) {\n    var mask = p.container.dom.append(bhvr.maskTagName || 'div', k.CLS.mask);\n    Monocle.Events.listenForContact(mask, {\n      start: function () { p.reader.dispatchEvent('monocle:magic:halt'); },\n      move: function (evt) { evt.preventDefault(); },\n      end: function () { p.reader.dispatchEvent('monocle:magic:init'); }\n    });\n    bhvr.fitMask(element, mask);\n    return mask;\n  }\n\n\n  // Make the active masks visible (by giving them a class -- override style\n  // in monoctrl.css).\n  //\n  function toggleHighlights() {\n    var cls = k.CLS.highlights;\n    if (p.container.dom.hasClass(cls)) {\n      p.container.dom.removeClass(cls);\n    } else {\n      p.container.dom.addClass(cls);\n    }\n  }\n\n\n  function disable() {\n    p.disabled = true;\n    draw();\n  }\n\n\n  function enable() {\n    p.disabled = false;\n    draw();\n  }\n\n\n  function filterElement(elem, behavior) {\n    if (typeof behavior.filterElement == 'function') {\n      return behavior.filterElement(elem);\n    }\n    return elem;\n  }\n\n\n  function maskAssigned(elem, mask, behavior) {\n    if (typeof behavior.maskAssigned == 'function') {\n      return behavior.maskAssigned(elem, mask);\n    }\n    return false;\n  }\n\n\n  API.createControlElements = createControlElements;\n  API.addBehavior = addBehavior;\n  API.draw = draw;\n  API.update = update;\n  API.toggleHighlights = toggleHighlights;\n\n  return API;\n}\n\n\nMonocle.Controls.Stencil.CLS = {\n  container: 'controls_stencil_container',\n  mask: 'controls_stencil_mask',\n  highlights: 'controls_stencil_highlighted'\n}\n\n\n\nMonocle.Controls.Stencil.Links = function (stencil) {\n  var API = { constructor: Monocle.Controls.Stencil.Links }\n\n  // Optionally specify the HTML tagname of the mask.\n  API.maskTagName = 'a';\n\n  // Returns an array of all the elements in the given doc that should\n  // be covered with a stencil mask for interactivity.\n  //\n  // (Hint: doc.querySelectorAll() is your friend.)\n  //\n  API.findElements = function (doc) {\n    return doc.querySelectorAll('a[href]');\n  }\n\n\n  // Return an element. It should usually be a child of the container element,\n  // with a className of the given maskClass. You set up the interactivity of\n  // the mask element here.\n  //\n  API.fitMask = function (link, mask) {\n    var hrefObject = deconstructHref(link);\n    if (hrefObject.internal) {\n      mask.setAttribute('href', 'javascript:\"Skip to chapter\"');\n      Monocle.Events.listen(mask, 'click', function (evt) {\n        stencil.properties.reader.skipToChapter(hrefObject.internal);\n        evt.preventDefault();\n      });\n    } else {\n      mask.setAttribute('href', hrefObject.external);\n      mask.setAttribute('target', '_blank');\n      link.setAttribute('target', '_blank'); // For good measure.\n    }\n  }\n\n\n  // Returns an object with either:\n  //\n  // - an 'external' property -- an absolute URL with a protocol,\n  // host & etc, which should be treated as an external resource (eg,\n  // open in new window)\n  //\n  //   OR\n  //\n  // - an 'internal' property -- a relative URL (with optional hash anchor),\n  //  that is treated as a link to component in the book\n  //\n  // A weird but useful property of <a> tags is that while\n  // link.getAttribute('href') will return the actual string value of the\n  // attribute (eg, 'foo.html'), link.href will return the absolute URL (eg,\n  // 'http://example.com/monocles/foo.html').\n  //\n  function deconstructHref(elem) {\n    var url = elem.href;\n    if (!elem.getAttribute('target')) {\n      var m = url.match(/([^#]*)(#.*)?$/);\n      var path = m[1];\n      var anchor = m[2] || '';\n      var cmpts = stencil.properties.reader.getBook().properties.componentIds;\n      for (var i = 0, ii = cmpts.length; i < ii; ++i) {\n        if (path.substr(0 - cmpts[i].length) == cmpts[i]) {\n          return { internal: cmpts[i] + anchor };\n        }\n      }\n    }\n    return { external: url };\n  }\n\n  return API;\n}\n\n\nMonocle.Controls.Stencil.DEFAULT_BEHAVIORS = [Monocle.Controls.Stencil.Links];\n"]],"start1":0,"start2":0,"length1":0,"length2":24347}]],"length":24347}
