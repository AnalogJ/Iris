{"ts":1355880947864,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * Monocle - A silky, tactile browser-based ebook JavaScript library.\n *\n * Copyright 2012, Joseph Pearson\n * Licensed under the MIT license.\n */\n\n\nMonocle = {\n  VERSION: \"3.0.0\"\n};\n\n\nMonocle.Dimensions = {};\nMonocle.Controls = {};\nMonocle.Flippers = {};\nMonocle.Panels = {};\n// A class that tests the browser environment for required capabilities and\n// known bugs (for which we have workarounds).\n//\nMonocle.Env = function () {\n\n  var API = { constructor: Monocle.Env }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    // Assign to a function before running survey in order to get\n    // results as they come in. The function should take two arguments:\n    // testName and value.\n    resultCallback: null\n  }\n\n  // These are private variables so they don't clutter up properties.\n  var css = Monocle.Browser.css;\n  var activeTestName = null;\n  var frameLoadCallback = null;\n  var testFrame = null;\n  var testFrameCntr = null;\n  var testFrameSize = 100;\n  var surveyCallback = null;\n\n\n  function survey(cb) {\n    surveyCallback = cb;\n    runNextTest();\n  }\n\n\n  function runNextTest() {\n    var test = envTests.shift();\n    if (!test) { return completed(); }\n    activeTestName = test[0];\n    try { test[1](); } catch (e) { result(e); }\n  }\n\n\n  // Each test should call this to say \"I'm finished, run the next test.\"\n  //\n  function result(val) {\n    API[activeTestName] = val;\n    if (p.resultCallback) { p.resultCallback(activeTestName, val); }\n    runNextTest();\n    return val;\n  }\n\n\n  // Invoked after all tests have run.\n  //\n  function completed() {\n    // Remove the test frame after a slight delay (otherwise Gecko spins).\n    Monocle.defer(removeTestFrame);\n\n    if (typeof surveyCallback == \"function\") {\n      fn = surveyCallback;\n      surveyCallback = null;\n      fn(API);\n    }\n  }\n\n\n  // A bit of sugar for simplifying a detection pattern: does this\n  // function exist?\n  //\n  // Pass a string snippet of JavaScript to be evaluated.\n  //\n  function testForFunction(str) {\n    return function () { result(typeof eval(str) == \"function\"); }\n  }\n\n\n  // A bit of sugar to indicate that the detection function for this test\n  // hasn't been written yet...\n  //\n  // Pass the value you want assigned for the test until it is implemented.\n  //\n  function testNotYetImplemented(rslt) {\n    return function () { result(rslt); }\n  }\n\n\n  // Loads (or reloads) a hidden iframe so that we can test browser features.\n  //\n  // cb is the callback that is fired when the test frame's content is loaded.\n  //\n  // src is optional, in which case it defaults to 4. If provided, it can be\n  // a number (specifying the number of pages of default content), or a string,\n  // which will be loaded as a URL.\n  //\n  function loadTestFrame(cb, src) {\n    if (!testFrame) { testFrame = createTestFrame(); }\n    frameLoadCallback = cb;\n\n    src = src || 4;\n\n    if (typeof src == \"number\") {\n      var pgs = [];\n      for (var i = 1, ii = src; i <= ii; ++i) {\n        pgs.push(\"<div>Page \"+i+\"</div>\");\n      }\n      var divStyle = [\n        \"display:inline-block\",\n        \"line-height:\"+testFrameSize+\"px\",\n        \"width:\"+testFrameSize+\"px\"\n      ].join(\";\");\n      src = \"javascript:'<!DOCTYPE html><html>\"+\n        '<head><meta name=\"time\" content=\"'+(new Date()).getTime()+'\" />'+\n        '<style>div{'+divStyle+'}</style></head>'+\n        '<body>'+pgs.join(\"\")+'</body>'+\n        \"</html>'\";\n    }\n\n    testFrame.src = src;\n  }\n\n\n  // Creates the hidden test frame and returns it.\n  //\n  function createTestFrame() {\n    testFrameCntr = document.createElement('div');\n    testFrameCntr.style.cssText = [\n      \"width:\"+testFrameSize+\"px\",\n      \"height:\"+testFrameSize+\"px\",\n      \"overflow:hidden\",\n      \"position:absolute\",\n      \"visibility:hidden\"\n    ].join(\";\");\n    document.body.appendChild(testFrameCntr);\n\n    var fr = document.createElement('iframe');\n    testFrameCntr.appendChild(fr);\n    fr.setAttribute(\"scrolling\", \"no\");\n    fr.style.cssText = [\n      \"width:100%\",\n      \"height:100%\",\n      \"border:none\",\n      \"background:#900\"\n    ].join(\";\");\n    fr.addEventListener(\n      \"load\",\n      function () {\n        if (!fr.contentDocument || !fr.contentDocument.body) { return; }\n        var bd = fr.contentDocument.body;\n        bd.style.cssText = ([\n          \"margin:0\",\n          \"padding:0\",\n          \"position:absolute\",\n          \"height:100%\",\n          \"width:100%\",\n          \"-webkit-column-width:\"+testFrameSize+\"px\",\n          \"-webkit-column-gap:0\",\n          \"-webkit-column-fill:auto\",\n          \"-moz-column-width:\"+testFrameSize+\"px\",\n          \"-moz-column-gap:0\",\n          \"-moz-column-fill:auto\",\n          \"-o-column-width:\"+testFrameSize+\"px\",\n          \"-o-column-gap:0\",\n          \"-o-column-fill:auto\",\n          \"column-width:\"+testFrameSize+\"px\",\n          \"column-gap:0\",\n          \"column-fill:auto\"\n        ].join(\";\"));\n        if (bd.scrollHeight > testFrameSize) {\n          bd.style.cssText += [\"min-width:200%\", \"overflow:hidden\"].join(\";\");\n          if (bd.scrollHeight <= testFrameSize) {\n            bd.className = \"column-force\";\n          } else {\n            bd.className = \"column-failed \"+bd.scrollHeight;\n          }\n        }\n        frameLoadCallback(fr);\n      },\n      false\n    );\n    return fr;\n  }\n\n\n  function removeTestFrame() {\n    if (testFrameCntr && testFrameCntr.parentNode) {\n      testFrameCntr.parentNode.removeChild(testFrameCntr);\n    }\n  }\n\n\n  function columnedWidth(fr) {\n    var bd = fr.contentDocument.body;\n    var de = fr.contentDocument.documentElement;\n    return Math.max(bd.scrollWidth, de.scrollWidth);\n  }\n\n\n  var envTests = [\n\n    // TEST FOR REQUIRED CAPABILITIES\n\n    [\"supportsW3CEvents\", testForFunction(\"window.addEventListener\")],\n    [\"supportsCustomEvents\", testForFunction(\"document.createEvent\")],\n    [\"supportsColumns\", function () {\n      result(css.supportsPropertyWithAnyPrefix('column-width'));\n    }],\n    [\"supportsTransform\", function () {\n      result(css.supportsProperty([\n        'transformProperty',\n        'WebkitTransform',\n        'MozTransform',\n        'OTransform',\n        'msTransform'\n      ]));\n    }],\n\n\n    // TEST FOR OPTIONAL CAPABILITIES\n\n    // Does it do CSS transitions?\n    [\"supportsTransition\", function () {\n      result(css.supportsPropertyWithAnyPrefix('transition'))\n    }],\n\n    // Can we find nodes in a document with an XPath?\n    //\n    [\"supportsXPath\", testForFunction(\"document.evaluate\")],\n\n    // Can we find nodes in a document natively with a CSS selector?\n    //\n    [\"supportsQuerySelector\", testForFunction(\"document.querySelector\")],\n\n    // Can we do 3d transforms?\n    //\n    [\"supportsTransform3d\", function () {\n      result(\n        css.supportsMediaQueryProperty('transform-3d') &&\n        css.supportsProperty([\n          'perspectiveProperty',\n          'WebkitPerspective',\n          'MozPerspective',\n          'OPerspective',\n          'msPerspective'\n        ])\n      );\n    }],\n\n\n    // Commonly-used browser functionality\n    [\"supportsOfflineCache\", function () {\n      result(typeof window.applicationCache != 'undefined');\n    }],\n\n    [\"supportsLocalStorage\", function () {\n      // NB: Some duplicitous early Android browsers claim to have\n      // localStorage, but calls to getItem() fail.\n      result(\n        typeof window.localStorage != \"undefined\" &&\n        typeof window.localStorage.getItem == \"function\"\n      )\n    }],\n\n\n    // CHECK OUT OUR CONTEXT\n\n    // Does the device have a MobileSafari-style touch interface?\n    //\n    [\"touch\", function () {\n      result(\n        ('ontouchstart' in window) ||\n        css.supportsMediaQueryProperty('touch-enabled')\n      );\n    }],\n\n    // Is the Reader embedded, or in the top-level window?\n    //\n    [\"embedded\", function () { result(top != self) }],\n\n\n    // TEST FOR CERTAIN RENDERING OR INTERACTION BUGS\n\n    // iOS (at least up to version 4.1) makes a complete hash of touch events\n    // when an iframe is overlapped by other elements. It's a dog's breakfast.\n    // See test/bugs/ios-frame-touch-bug for details.\n    //\n    [\"brokenIframeTouchModel\", function () {\n      result(Monocle.Browser.iOSVersionBelow(\"4.2\"));\n    }],\n\n    // Webkit-based browsers put floated elements in the wrong spot when\n    // columns are used -- they appear way down where they would be if there\n    // were no columns.  Presumably the float positions are calculated before\n    // the columns. A bug has been lodged, and it's fixed in recent WebKits.\n    //\n    [\"floatsIgnoreColumns\", function () {\n      if (!Monocle.Browser.is.WebKit) { return result(false); }\n      match = navigator.userAgent.match(/AppleWebKit\\/([\\d\\.]+)/);\n      if (!match) { return result(false); }\n      return result(match[1] < \"534.30\");\n    }],\n\n    // The latest engines all agree that if a body is translated leftwards,\n    // its scrollWidth is shortened. But some older WebKits (notably iOS4)\n    // do not subtract translateX values from scrollWidth. In this case,\n    // we should not add the translate back when calculating the width.\n    //\n    [\"widthsIgnoreTranslate\", function () {\n      loadTestFrame(function (fr) {\n        var firstWidth = columnedWidth(fr);\n        var s = fr.contentDocument.body.style;\n        var props = css.toDOMProps(\"transform\");\n        for (var i = 0, ii = props.length; i < ii; ++i) {\n          s[props[i]] = \"translateX(-600px)\";\n        }\n        var secondWidth = columnedWidth(fr);\n        for (i = 0, ii = props.length; i < ii; ++i) {\n          s[props[i]] = \"none\";\n        }\n        result(secondWidth == firstWidth);\n      });\n    }],\n\n    // On Android browsers, if the component iframe has a relative width (ie,\n    // 100%), the width of the entire browser will keep expanding and expanding\n    // to fit the width of the body of the iframe (which, with columns, is\n    // massive). So, 100% is treated as \"of the body content\" rather than \"of\n    // the parent dimensions\". In this scenario, we need to give the component\n    // iframe a fixed width in pixels.\n    //\n    // In iOS, the frame is clipped by overflow:hidden, so this doesn't seem to\n    // be a problem.\n    //\n    [\"relativeIframeExpands\", function () {\n      result(navigator.userAgent.indexOf(\"Android 2\") >= 0);\n    }],\n\n    // iOS3 will pause JavaScript execution if it gets a style-change + a\n    // scroll change on a component body. Weirdly, this seems to break GBCR\n    // in iOS4.\n    //\n    [\"scrollToApplyStyle\", function () {\n      result(Monocle.Browser.iOSVersionBelow(\"4\"));\n    }],\n\n\n    // TEST FOR OTHER QUIRKY BROWSER BEHAVIOUR\n\n    // Older versions of WebKit (iOS3, Kindle3) need a min-width set on the\n    // body of the iframe at 200%. This forces columns. But when this\n    // min-width is set, it's more difficult to recognise 1 page components,\n    // so we generally don't want to force it unless we have to.\n    //\n    [\"forceColumns\", function () {\n      loadTestFrame(function (fr) {\n        var bd = fr.contentDocument.body;\n        result(bd.className ? true : false);\n      });\n    }],\n\n    // A component iframe's body is absolutely positioned. This means that\n    // the documentElement should have a height of 0, since it contains nothing\n    // other than an absolutely positioned element.\n    //\n    // But for some browsers (Gecko and Opera), the documentElement is as\n    // wide as the full columned content, and the body is only as wide as\n    // the iframe element (ie, the first column).\n    //\n    // It gets weirder. Gecko sometimes behaves like WebKit (not clipping the\n    // body) IF the component has been loaded via HTML/JS/Nodes, not URL. Still\n    // can't reproduce outside Monocle.\n    //\n    // FIXME: If we can figure out a reliable behaviour for Gecko, we should\n    // use it to precalculate the workaround. At the moment, this test isn't\n    // used, but it belongs in src/dimensions/columns.js#columnedDimensions().\n    //\n    // [\"iframeBodyWidthClipped\", function () {\n    //   loadTestFrame(function (fr) {\n    //     var doc = fr.contentDocument;\n    //     result(\n    //       doc.body.scrollWidth <= testFrameSize &&\n    //       doc.documentElement.scrollWidth > testFrameSize\n    //     );\n    //   })\n    // }],\n\n    // Finding the page that a given HTML node is on is typically done by\n    // calculating the offset of its rectange from the body's rectangle.\n    //\n    // But if this information isn't provided by the browser, we need to use\n    // node.scrollIntoView and check the scrollOffset. Basically iOS3 is the\n    // only target platform that doesn't give us the rectangle info.\n    //\n    [\"findNodesByScrolling\", function () {\n      result(typeof document.body.getBoundingClientRect !== \"function\");\n    }],\n\n    // In MobileSafari browsers, iframes are rendered at the width and height\n    // of their content, rather than having scrollbars. So in that case, it's\n    // the containing element (the \"sheaf\") that must be scrolled, not the\n    // iframe body.\n    //\n    [\"sheafIsScroller\", function () {\n      loadTestFrame(function (fr) {\n        result(fr.parentNode.scrollWidth > testFrameSize);\n      });\n    }],\n\n    // For some reason, iOS MobileSafari sometimes loses track of a page after\n    // slideOut -- it thinks it has an x-translation of 0, rather than -768 or\n    // whatever. So the page gets \"stuck\" there, until it is given a non-zero\n    // x-translation. The workaround is to set a non-zero duration on the jumpIn,\n    // which seems to force WebKit to recalculate the x of the page. Weird, yeah.\n    //\n    [\"stickySlideOut\", function () {\n      result(Monocle.Browser.is.MobileSafari);\n    }],\n\n\n    // Chrome and Firefox incorrectly clip text when the dimensions of\n    // a page are not an integer. IE10 clips text when the page dimensions\n    // are rounded.\n    //\n    ['roundPageDimensions', function () {\n      result(!Monocle.Browser.is.IE);\n    }],\n\n\n\n    // In IE10, the <html> element of the iframe's document has scrollbars,\n    // unless you set its style.overflow to 'hidden'.\n    //\n    ['documentElementHasScrollbars', function () {\n      result(Monocle.Browser.is.IE);\n    }],\n\n\n    // Older versions of iOS (<6) would render blank pages if they were\n    // off the screen when their layout/position was updated.\n    //\n    ['offscreenRenderingClipped', function () {\n      result(Monocle.Browser.iOSVersionBelow('6'));\n    }],\n\n\n    // Gecko is better at loading content with document.write than with\n    // javascript: URLs. With the latter, it tends to put cruft in history,\n    // and gets confused by <base>.\n    ['loadHTMLWithDocWrite', function () {\n      result(Monocle.Browser.is.Gecko);\n    }]\n\n  ];\n\n\n  function isCompatible() {\n    return (\n      API.supportsW3CEvents &&\n      API.supportsCustomEvents &&\n      API.supportsColumns &&\n      API.supportsTransform &&\n      !API.brokenIframeTouchModel\n    );\n  }\n\n\n  API.survey = survey;\n  API.isCompatible = isCompatible;\n\n  return API;\n}\n;\n// A class for manipulating CSS properties in a browser-engine-aware way.\n//\nMonocle.CSS = function () {\n\n  var API = { constructor: Monocle.CSS }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    guineapig: document.createElement('div')\n  }\n\n\n  // Returns engine-specific properties,\n  //\n  // eg:\n  //\n  //  toCSSProps('transform')\n  //\n  // ... in WebKit, this will return:\n  //\n  //  ['transform', '-webkit-transform']\n  //\n  function toCSSProps(prop) {\n    var props = [prop];\n    var eng = k.engines.indexOf(Monocle.Browser.engine);\n    if (eng) {\n      var pf = k.prefixes[eng];\n      if (pf) {\n        props.push(pf+prop);\n      }\n    }\n    return props;\n  }\n\n\n  // Returns an engine-specific CSS string.\n  //\n  // eg:\n  //\n  //   toCSSDeclaration('column-width', '300px')\n  //\n  // ... in Mozilla, this will return:\n  //\n  //   \"column-width: 300px; -moz-column-width: 300px;\"\n  //\n  function toCSSDeclaration(prop, val) {\n    var props = toCSSProps(prop);\n    for (var i = 0, ii = props.length; i < ii; ++i) {\n      props[i] += \": \"+val+\";\";\n    }\n    return props.join(\"\");\n  }\n\n\n  // Returns an array of DOM properties specific to this engine.\n  //\n  // eg:\n  //\n  //   toDOMProps('column-width')\n  //\n  // ... in Opera, this will return:\n  //\n  //   [columnWidth, OColumnWidth]\n  //\n  function toDOMProps(prop) {\n    var parts = prop.split('-');\n    for (var i = parts.length; i > 0; --i) {\n      parts[i] = capStr(parts[i]);\n    }\n\n    var props = [parts.join('')];\n    var eng = k.engines.indexOf(Monocle.Browser.engine);\n    if (eng) {\n      var pf = k.domprefixes[eng];\n      if (pf) {\n        parts[0] = capStr(parts[0]);\n        props.push(pf+parts.join(''));\n      }\n    }\n    return props;\n  }\n\n\n  // Is this exact property (or any in this array of properties) supported\n  // by this engine?\n  //\n  function supportsProperty(props) {\n    for (var i in props) {\n      if (p.guineapig.style[props[i]] !== undefined) { return true; }\n    }\n    return false;\n  } // Thanks modernizr!\n\n\n\n  // Is this property (or a prefixed variant) supported by this engine?\n  //\n  function supportsPropertyWithAnyPrefix(prop) {\n    return supportsProperty(toDOMProps(prop));\n  }\n\n\n  function supportsMediaQuery(query) {\n    var gpid = \"monocle_guineapig\";\n    p.guineapig.id = gpid;\n    var st = document.createElement('style');\n    st.textContent = query+'{#'+gpid+'{height:3px}}';\n    (document.head || document.getElementsByTagName('head')[0]).appendChild(st);\n    document.documentElement.appendChild(p.guineapig);\n\n    var result = p.guineapig.offsetHeight === 3;\n\n    st.parentNode.removeChild(st);\n    p.guineapig.parentNode.removeChild(p.guineapig);\n\n    return result;\n  } // Thanks modernizr!\n\n\n  function supportsMediaQueryProperty(prop) {\n    return supportsMediaQuery(\n      '@media (' + k.prefixes.join(prop+'),(') + 'monocle__)'\n    );\n  }\n\n\n  function capStr(wd) {\n    return wd ? wd.charAt(0).toUpperCase() + wd.substr(1) : \"\";\n  }\n\n\n  API.toCSSProps = toCSSProps;\n  API.toCSSDeclaration = toCSSDeclaration;\n  API.toDOMProps = toDOMProps;\n  API.supportsProperty = supportsProperty;\n  API.supportsPropertyWithAnyPrefix = supportsPropertyWithAnyPrefix;\n  API.supportsMediaQuery = supportsMediaQuery;\n  API.supportsMediaQueryProperty = supportsMediaQueryProperty;\n\n  return API;\n}\n\n\nMonocle.CSS.engines = [\"W3C\", \"WebKit\", \"Gecko\", \"Opera\", \"IE\", \"Konqueror\"];\nMonocle.CSS.prefixes = [\"\", \"-webkit-\", \"-moz-\", \"-o-\", \"-ms-\", \"-khtml-\"];\nMonocle.CSS.domprefixes = [\"\", \"Webkit\", \"Moz\", \"O\", \"ms\", \"Khtml\"];\n// STUBS - simple debug functions and polyfills to normalise client\n// execution environments.\n\n\n// A little console stub if not initialized in a console-equipped browser.\n//\nif (typeof window.console == \"undefined\") {\n  window.console = { messages: [] }\n  window.console.log = function (msg) {\n    this.messages.push(msg);\n  }\n  window.console.warn = window.console.log;\n}\n\n\n// A simple version of console.dir that works on iOS.\n//\nwindow.console.compatDir = function (obj) {\n  var stringify = function (o) {\n    var parts = [];\n    for (x in o) {\n      parts.push(x + \": \" + o[x]);\n    }\n    return parts.join(\";\\n\");\n  }\n\n  var out = stringify(obj);\n  window.console.log(out);\n  return out;\n}\n\n\n// This is called by Monocle methods and practices that are no longer\n// recommended and will soon be removed.\n//\nwindow.console.deprecation = function (msg) {\n  console.warn(\"[DEPRECATION]: \"+msg);\n  if (typeof console.trace == \"function\") {\n    console.trace();\n  }\n}\n\n\n// A convenient alias for setTimeout that assumes 0 if no timeout is specified.\n//\nMonocle.defer = function (fn, time) {\n  if (fn && typeof fn == \"function\") {\n    return setTimeout(fn, time || 0);\n  }\n}\n;\nMonocle.Browser = {};\n\n// Compare the user-agent string to a string or regex pattern.\n//\nMonocle.Browser.uaMatch = function (test) {\n  var ua = navigator.userAgent;\n  if (typeof test == \"string\") { return ua.indexOf(test) >= 0; }\n  return !!ua.match(test);\n}\n\n\n// Detect the browser engine and set boolean flags for reference.\n//\nMonocle.Browser.is = {\n  IE: !!(window.attachEvent && !Monocle.Browser.uaMatch('Opera')),\n  Opera: Monocle.Browser.uaMatch('Opera'),\n  WebKit: Monocle.Browser.uaMatch(/Apple\\s?WebKit/),\n  Gecko: Monocle.Browser.uaMatch('Gecko') && !Monocle.Browser.uaMatch('KHTML'),\n  MobileSafari: Monocle.Browser.uaMatch(/AppleWebKit.*Mobile/)\n}\n\n\n// Set the browser engine string.\n//\nif (Monocle.Browser.is.IE) {\n  Monocle.Browser.engine = \"IE\";\n} else if (Monocle.Browser.is.Opera) {\n  Monocle.Browser.engine = \"Opera\";\n} else if (Monocle.Browser.is.WebKit) {\n  Monocle.Browser.engine = \"WebKit\";\n} else if (Monocle.Browser.is.Gecko) {\n  Monocle.Browser.engine = \"Gecko\";\n} else {\n  console.warn(\"Unknown engine; assuming W3C compliant.\");\n  Monocle.Browser.engine = \"W3C\";\n}\n\n\n// Detect the client platform (typically device/operating system).\n//\nMonocle.Browser.on = {\n  iPhone: Monocle.Browser.is.MobileSafari && screen.width == 320,\n  iPad: Monocle.Browser.is.MobileSafari && screen.width == 768,\n  UIWebView: (\n    Monocle.Browser.is.MobileSafari &&\n    !Monocle.Browser.uaMatch('Safari') &&\n    !navigator.standalone\n  ),\n  BlackBerry: Monocle.Browser.uaMatch('BlackBerry'),\n  Android: (\n    Monocle.Browser.uaMatch('Android') ||\n    Monocle.Browser.uaMatch(/Linux;.*EBRD/) // Sony Readers\n  ),\n  MacOSX: (\n    Monocle.Browser.uaMatch('Mac OS X') &&\n    !Monocle.Browser.is.MobileSafari\n  ),\n  Kindle3: Monocle.Browser.uaMatch(/Kindle\\/3/)\n}\n\n\n// It is only because MobileSafari is responsible for so much anguish that\n// we special-case it here. Not a badge of honour.\n//\nif (Monocle.Browser.is.MobileSafari) {\n  (function () {\n    var ver = navigator.userAgent.match(/ OS ([\\d_]+)/);\n    if (ver) {\n      Monocle.Browser.iOSVersion = ver[1].replace(/_/g, '.');\n    } else {\n      console.warn(\"Unknown MobileSafari user agent: \"+navigator.userAgent);\n    }\n  })();\n}\nMonocle.Browser.iOSVersionBelow = function (strOrNum) {\n  return !!Monocle.Browser.iOSVersion && Monocle.Browser.iOSVersion < strOrNum;\n}\n\n\n// Some browser environments are too slow or too problematic for\n// special animation effects.\n//\n// FIXME: These tests are too opinionated. Replace with more targeted tests.\n//\nMonocle.Browser.renders = {\n  eInk: Monocle.Browser.on.Kindle3,\n  slow: Monocle.Browser.on.Android || Monocle.Browser.on.Blackberry\n}\n\n\n// A helper class for sniffing CSS features and creating CSS rules\n// appropriate to the current rendering engine.\n//\nMonocle.Browser.css = new Monocle.CSS();\n\n\n// During Reader initialization, this method is called to create the\n// \"environment\", which tests for the existence of various browser\n// features and bugs, then invokes the callback to continue initialization.\n//\n// If the survey has already been conducted and the env exists, calls\n// callback immediately.\n//\nMonocle.Browser.survey = function (callback) {\n  if (!Monocle.Browser.env) {\n    Monocle.Browser.env = new Monocle.Env();\n    Monocle.Browser.env.survey(callback);\n  } else if (typeof callback == \"function\") {\n    callback();\n  }\n}\n;\n// A shortcut for creating a bookdata object from a 'data' hash.\n//\n// eg:\n//\n//   Monocle.bookData({ components: ['intro.html', 'ch1.html', 'ch2.html'] });\n//\n// All keys in the 'data' hash are optional:\n//\n//   components: must be an array of component urls\n//   chapters: must be an array of nested chapters (the usual bookdata structure)\n//   metadata: must be a hash of key/values\n//   getComponentFn: override the default way to fetch components via id\n//\nMonocle.bookData = function (data) {\n  return {\n    getComponents: function () {\n      return data.components || ['anonymous'];\n    },\n    getContents: function () {\n      return data.chapters || [];\n    },\n    getComponent: data.getComponent || function (id) {\n      return { url: id }\n    },\n    getMetaData: function (key) {\n      return (data.metadata || {})[key];\n    },\n    data: data\n  }\n}\n\n\n// A shortcut for creating a bookdata object from an array of element ids.\n//\n// eg:\n//\n//   Monocle.bookDataFromIds(['part1', 'part2']);\n//\nMonocle.bookDataFromIds = function (elementIds) {\n  return Monocle.bookData({\n    components: elementIds,\n    getComponent: function (cmptId) {\n      return { nodes: [document.getElementById(cmptId)] }\n    }\n  });\n}\n\n\n// A shortcut for creating a bookdata object from an array of nodes.\n//\n// eg:\n//\n//   Monocle.bookDataFromNodes([document.getElementById('content')]);\n//\nMonocle.bookDataFromNodes = function (nodes) {\n  return Monocle.bookData({\n    getComponent: function (n) { return { 'nodes': nodes }; }\n  });\n}\n;\nMonocle.Factory = function (element, label, index, reader) {\n\n  var API = { constructor: Monocle.Factory };\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    element: element,\n    label: label,\n    index: index,\n    reader: reader,\n    prefix: reader.properties.classPrefix || ''\n  }\n\n\n  // If index is null, uses the first available slot. If index is not null and\n  // the slot is not free, throws an error.\n  //\n  function initialize() {\n    if (!p.label) { return; }\n    // Append the element to the reader's graph of DOM elements.\n    var node = p.reader.properties.graph;\n    node[p.label] = node[p.label] || [];\n    if (typeof p.index == 'undefined' && node[p.label][p.index]) {\n      throw('Element already exists in graph: '+p.label+'['+p.index+']');\n    } else {\n      p.index = p.index || node[p.label].length;\n    }\n    node[p.label][p.index] = p.element;\n\n    // Add the label as a class name.\n    addClass(p.label);\n  }\n\n\n  // Finds an element that has been created in the context of the current\n  // reader, with the given label. If oIndex is not provided, returns first.\n  // If oIndex is provided (eg, n), returns the nth element with the label.\n  //\n  function find(oLabel, oIndex) {\n    if (!p.reader.properties.graph[oLabel]) {\n      return null;\n    }\n    return p.reader.properties.graph[oLabel][oIndex || 0];\n  }\n\n\n  // Takes an elements and assimilates it into the reader -- essentially\n  // giving it a \"dom\" object of it's own. It will then be accessible via find.\n  //\n  // Note that (as per comments for initialize), if oIndex is provided and\n  // there is no free slot in the array for this label at that index, an\n  // error will be thrown.\n  //\n  function claim(oElement, oLabel, oIndex) {\n    return oElement.dom = new Monocle.Factory(\n      oElement,\n      oLabel,\n      oIndex,\n      p.reader\n    );\n  }\n\n\n  // Create an element with the given label.\n  //\n  // The last argument (whether third or fourth) is the options hash. Your\n  // options are:\n  //\n  //   class - the classname for the element. Must only be one name.\n  //   html - the innerHTML for the element.\n  //   text - the innerText for the element (an alternative to html, simpler).\n  //\n  // Returns the created element.\n  //\n  function make(tagName, oLabel, index_or_options, or_options) {\n    var oIndex, options;\n    if (arguments.length == 1) {\n      oLabel = null,\n      oIndex = 0;\n      options = {};\n    } else if (arguments.length == 2) {\n      oIndex = 0;\n      options = {};\n    } else if (arguments.length == 4) {\n      oIndex = arguments[2];\n      options = arguments[3];\n    } else if (arguments.length == 3) {\n      var lastArg = arguments[arguments.length - 1];\n      if (typeof lastArg == \"number\") {\n        oIndex = lastArg;\n        options = {};\n      } else {\n        oIndex = 0;\n        options = lastArg;\n      }\n    }\n\n    var oElement = document.createElement(tagName);\n    claim(oElement, oLabel, oIndex);\n    if (options['class']) {\n      oElement.className += \" \"+p.prefix+options['class'];\n    }\n    if (options['html']) {\n      oElement.innerHTML = options['html'];\n    }\n    if (options['text']) {\n      oElement.appendChild(document.createTextNode(options['text']));\n    }\n\n    return oElement;\n  }\n\n\n  // Creates an element by passing all the given arguments to make. Then\n  // appends the element as a child of the current element.\n  //\n  function append(tagName, oLabel, index_or_options, or_options) {\n    var oElement = make.apply(this, arguments);\n    p.element.appendChild(oElement);\n    return oElement;\n  }\n\n\n  // Returns an array of [label, index, reader] for the given element.\n  // A simple way to introspect the arguments required for #find, for eg.\n  //\n  function address() {\n    return [p.label, p.index, p.reader];\n  }\n\n\n  // Apply a set of style rules (hash or string) to the current element.\n  // See Monocle.Styles.applyRules for more info.\n  //\n  function setStyles(rules) {\n    return Monocle.Styles.applyRules(p.element, rules);\n  }\n\n\n  function setBetaStyle(property, value) {\n    return Monocle.Styles.affix(p.element, property, value);\n  }\n\n\n  // ClassName manipulation functions - with thanks to prototype.js!\n\n  // Returns true if one of the current element's classnames matches name --\n  // classPrefix aware (so don't concate the prefix onto it).\n  //\n  function hasClass(name) {\n    name = p.prefix + name;\n    var klass = p.element.className;\n    if (!klass) { return false; }\n    if (klass == name) { return true; }\n    return new RegExp(\"(^|\\\\s)\"+name+\"(\\\\s|$)\").test(klass);\n  }\n\n\n  // Adds name to the classnames of the current element (prepending the\n  // reader's classPrefix first).\n  //\n  function addClass(name) {\n    if (hasClass(name)) { return; }\n    var gap = p.element.className ? ' ' : '';\n    return p.element.className += gap+p.prefix+name;\n  }\n\n\n  // Removes (classPrefix+)name from the classnames of the current element.\n  //\n  function removeClass(name) {\n    var reName = new RegExp(\"(^|\\\\s+)\"+p.prefix+name+\"(\\\\s+|$)\");\n    var reTrim = /^\\s+|\\s+$/g;\n    var klass = p.element.className;\n    p.element.className = klass.replace(reName, ' ').replace(reTrim, '');\n    return p.element.className;\n  }\n\n\n  API.find = find;\n  API.claim = claim;\n  API.make = make;\n  API.append = append;\n  API.address = address;\n\n  API.setStyles = setStyles;\n  API.setBetaStyle = setBetaStyle;\n  API.hasClass = hasClass;\n  API.addClass = addClass;\n  API.removeClass = removeClass;\n\n  initialize();\n\n  return API;\n}\n;\nMonocle.Events = {};\n\n\n// Fire a custom event on a given target element. The attached data object will\n// be available to all listeners at evt.m.\n//\n// Internet Explorer does not permit custom events; we'll wait for a\n// version of IE that supports the W3C model.\n//\nMonocle.Events.dispatch = function (elem, evtType, data, cancelable) {\n  if (!document.createEvent) {\n    return true;\n  }\n  var evt = document.createEvent(\"Events\");\n  evt.initEvent(evtType, false, cancelable || false);\n  evt.m = data;\n  try {\n    return elem.dispatchEvent(evt);\n  } catch(e) {\n    console.warn(\"Failed to dispatch event: \"+evtType);\n    return false;\n  }\n}\n\n\n// Register a function to be invoked when an event fires.\n//\nMonocle.Events.listen = function (elem, evtType, fn, useCapture) {\n  if (typeof elem == \"string\") { elem = document.getElementById(elem); }\n  return elem.addEventListener(evtType, fn, useCapture || false);\n}\n\n\n// De-register a function from an event.\n//\nMonocle.Events.deafen = function (elem, evtType, fn, useCapture) {\n  if (typeof elem == \"string\") { elem = document.getElementById(elem); }\n  return elem.removeEventListener(evtType, fn, useCapture || false);\n}\n\n\n// Register a series of functions to listen for the start, move, end\n// events of a mouse or touch interaction.\n//\n// 'fns' argument is an object like:\n//\n//   {\n//     'start': function () { ... },\n//     'move': function () { ... },\n//     'end': function () { ... },\n//     'cancel': function () { ... }\n//   }\n//\n// All of the functions in this object are optional.\n//\n// Each function is passed the event, with additional generic info about the\n// cursor/touch position:\n//\n//    event.m.offsetX (& offsetY) -- relative to top-left of the element\n//                                   on which the event fired\n//    event.m.registrantX (& registrantY) -- relative to top-left of element\n//                                           on which the event is listening\n//\n// 'options' argument:\n//\n//   {\n//     'useCapture': true/false\n//   }\n//\n// Returns an object that can later be passed to Monocle.Events.deafenForContact\n//\nMonocle.Events.listenForContact = function (elem, fns, options) {\n  var listeners = {};\n\n  var cursorInfo = function (evt, ci) {\n    evt.m = {\n      pageX: ci.pageX,\n      pageY: ci.pageY,\n      clientX: ci.clientX,\n      clientY: ci.clientY,\n      screenX: ci.screenX,\n      screenY: ci.screenY\n    };\n\n    var target = evt.target || evt.srcElement;\n    while (target.nodeType != 1 && target.parentNode) {\n      target = target.parentNode;\n    }\n\n    // The position of contact from the top left of the element\n    // on which the event fired.\n    var offset = offsetFor(evt, target);\n    evt.m.offsetX = offset[0];\n    evt.m.offsetY = offset[1];\n\n    // The position of contact from the top left of the element\n    // on which the event is listening.\n    if (\n      evt.currentTarget &&\n      typeof evt.currentTarget.offsetLeft != 'undefined'\n    ) {\n      offset = offsetFor(evt, evt.currentTarget);\n      evt.m.registrantX = offset[0];\n      evt.m.registrantY = offset[1];\n    }\n\n    return evt;\n  }\n\n\n  var offsetFor = function (evt, elem) {\n    var r;\n    if (elem.getBoundingClientRect) {\n      // Why subtract documentElement position? It's always zero, right?\n      // Nope, not on Android when zoomed in.\n      var dr = document.documentElement.getBoundingClientRect();\n      var er = elem.getBoundingClientRect();\n      r = { left: er.left - dr.left, top: er.top - dr.top };\n    } else {\n      r = { left: elem.offsetLeft, top: elem.offsetTop }\n      while (elem = elem.offsetParent) {\n        if (elem.offsetLeft || elem.offsetTop) {\n          r.left += elem.offsetLeft;\n          r.top += elem.offsetTop;\n        }\n      }\n    }\n    return [evt.m.pageX - r.left, evt.m.pageY - r.top];\n  }\n\n\n  var capture = (options && options.useCapture) || false;\n\n  if (!Monocle.Browser.env.touch) {\n    if (fns.start) {\n      listeners.mousedown = function (evt) {\n        if (evt.button != 0) { return; }\n        fns.start(cursorInfo(evt, evt));\n      }\n      Monocle.Events.listen(elem, 'mousedown', listeners.mousedown, capture);\n    }\n    if (fns.move) {\n      listeners.mousemove = function (evt) {\n        fns.move(cursorInfo(evt, evt));\n      }\n      Monocle.Events.listen(elem, 'mousemove', listeners.mousemove, capture);\n    }\n    if (fns.end) {\n      listeners.mouseup = function (evt) {\n        fns.end(cursorInfo(evt, evt));\n      }\n      Monocle.Events.listen(elem, 'mouseup', listeners.mouseup, capture);\n    }\n    if (fns.cancel) {\n      listeners.mouseout = function (evt) {\n        obj = evt.relatedTarget || evt.fromElement;\n        while (obj && (obj = obj.parentNode)) {\n          if (obj == elem) { return; }\n        }\n        fns.cancel(cursorInfo(evt, evt));\n      }\n      Monocle.Events.listen(elem, 'mouseout', listeners.mouseout, capture);\n    }\n  } else {\n    if (fns.start) {\n      listeners.touchstart = function (evt) {\n        if (evt.touches.length > 1) { return; }\n        fns.start(cursorInfo(evt, evt.targetTouches[0]));\n      }\n    }\n    if (fns.move) {\n      listeners.touchmove = function (evt) {\n        if (evt.touches.length > 1) { return; }\n        fns.move(cursorInfo(evt, evt.targetTouches[0]));\n      }\n    }\n    if (fns.end) {\n      listeners.touchend = function (evt) {\n        fns.end(cursorInfo(evt, evt.changedTouches[0]));\n      }\n    }\n    if (fns.cancel) {\n      listeners.touchcancel = function (evt) {\n        fns.cancel(cursorInfo(evt, evt.changedTouches[0]));\n      }\n    }\n\n    for (etype in listeners) {\n      Monocle.Events.listen(elem, etype, listeners[etype], capture);\n    }\n  }\n\n  return listeners;\n}\n\n\n// The 'listeners' argument is a hash of event names and the functions that\n// are registered to them -- de-registers the functions from the events.\n//\nMonocle.Events.deafenForContact = function (elem, listeners) {\n  for (evtType in listeners) {\n    Monocle.Events.deafen(elem, evtType, listeners[evtType]);\n  }\n}\n\n\n// Looks for start/end events on an element without move events in\n// between. Fires on the end event.\n//\n// Also sets up a dummy click event on Kindle3, so that the elem becomes a\n// cursor target.\n//\n// If the optional activeClass string is provided, and if the element was\n// created by a Monocle.Factory, then the activeClass will be applied to the\n// element while it is being tapped.\n//\n// Returns a listeners object that you should pass to deafenForTap if you\n// need to.\nMonocle.Events.listenForTap = function (elem, fn, activeClass) {\n  var tapPos = null;\n\n  // On Kindle, register a noop function with click to make the elem a\n  // cursor target.\n  if (Monocle.Browser.on.Kindle3) {\n    Monocle.Events.listen(elem, 'click', function () {});\n  }\n\n  var annul = function () {\n    tapPos = null;\n    if (activeClass && elem.dom) { elem.dom.removeClass(activeClass); }\n  }\n\n  var cancel = function () {\n    if (tapPos) { annul(); }\n  }\n\n  Monocle.Events.listen(window, 'monocle:contact:cancel', cancel);\n\n  return Monocle.Events.listenForContact(\n    elem,\n    {\n      start: function (evt) {\n        tapPos = [evt.m.pageX, evt.m.pageY];\n        if (elem.getBoundingClientRect) {\n          elemRect = elem.getBoundingClientRect();\n        }\n        if (activeClass && elem.dom) { elem.dom.addClass(activeClass); }\n      },\n      move: cancel,\n      end: function (evt) {\n        if (tapPos) {\n          evt.m.pageXStart = tapPos[0];\n          evt.m.pageYStart = tapPos[1];\n          fn(evt);\n        }\n        annul();\n      },\n      cancel: cancel\n    },\n    {\n      useCapture: false\n    }\n  );\n}\n\n\nMonocle.Events.deafenForTap = Monocle.Events.deafenForContact;\n\n// Listen for the next transition-end event on the given element, call\n// the function, then deafen.\n//\n// Returns a function that can be used to cancel the listen early.\n//\nMonocle.Events.afterTransition = function (elem, fn) {\n  var evtName = \"transitionend\";\n  if (Monocle.Browser.is.WebKit) {\n    evtName = 'webkitTransitionEnd';\n  } else if (Monocle.Browser.is.Opera) {\n    evtName =  'oTransitionEnd';\n  }\n  var l = null, cancel = null;\n  l = function () { fn(); cancel(); }\n  cancel = function () { Monocle.Events.deafen(elem, evtName, l); }\n  Monocle.Events.listen(elem, evtName, l);\n  return cancel;\n}\n;\nMonocle.Styles = {\n\n  // Takes a hash and returns a string.\n  rulesToString: function (rules) {\n    if (typeof rules != 'string') {\n      var parts = [];\n      for (var declaration in rules) {\n        parts.push(declaration+\": \"+rules[declaration]+\";\")\n      }\n      rules = parts.join(\" \");\n    }\n    return rules;\n  },\n\n\n  // Takes a hash or string of CSS property assignments and applies them\n  // to the element.\n  //\n  applyRules: function (elem, rules) {\n    rules = Monocle.Styles.rulesToString(rules);\n    elem.style.cssText += ';'+rules;\n    return elem.style.cssText;\n  },\n\n\n  // Generates cross-browser properties for a given property.\n  // ie, affix(<elem>, 'transition', 'linear 100ms') would apply that value\n  // to webkitTransition for WebKit browsers, and to MozTransition for Gecko.\n  //\n  affix: function (elem, property, value) {\n    var target = elem.style ? elem.style : elem;\n    var props = Monocle.Browser.css.toDOMProps(property);\n    while (props.length) { target[props.shift()] = value; }\n  },\n\n\n  setX: function (elem, x) {\n    var s = elem.style;\n    if (typeof x == \"number\") { x += \"px\"; }\n    if (Monocle.Browser.env.supportsTransform3d) {\n      s.webkitTransform = \"translate3d(\"+x+\", 0, 0)\";\n    } else {\n      s.webkitTransform = \"translateX(\"+x+\")\";\n    }\n    s.MozTransform = s.OTransform = s.transform = \"translateX(\"+x+\")\";\n    return x;\n  },\n\n\n  setY: function (elem, y) {\n    var s = elem.style;\n    if (typeof y == \"number\") { y += \"px\"; }\n    if (Monocle.Browser.env.supportsTransform3d) {\n      s.webkitTransform = \"translate3d(0, \"+y+\", 0)\";\n    } else {\n      s.webkitTransform = \"translateY(\"+y+\")\";\n    }\n    s.MozTransform = s.OTransform = s.transform = \"translateY(\"+y+\")\";\n    return y;\n  },\n\n\n  getX: function (elem) {\n    var currStyle = document.defaultView.getComputedStyle(elem, null);\n    var re = /matrix\\([^,]+,[^,]+,[^,]+,[^,]+,\\s*([^,]+),[^\\)]+\\)/;\n    var props = Monocle.Browser.css.toDOMProps('transform');\n    var matrix = null;\n    while (props.length && !matrix) {\n      matrix = currStyle[props.shift()];\n    }\n    return parseInt(matrix.match(re)[1]);\n  },\n\n\n  transitionFor: function (elem, prop, duration, timing, delay) {\n    var tProps = Monocle.Browser.css.toDOMProps('transition');\n    var pProps = Monocle.Browser.css.toCSSProps(prop);\n    timing = timing || \"linear\";\n    delay = (delay || 0)+\"ms\";\n    for (var i = 0, ii = tProps.length; i < ii; ++i) {\n      var t = \"none\";\n      if (duration) {\n        t = [pProps[i], duration+\"ms\", timing, delay].join(\" \");\n      }\n      elem.style[tProps[i]] = t;\n    }\n  }\n\n}\n\n\n// These rule definitions are more or less compulsory for Monocle to behave\n// as expected. Which is why they appear here and not in the stylesheet.\n// Adjust them if you know what you're doing.\n//\nMonocle.Styles.container = {\n  \"position\": \"absolute\",\n  \"overflow\": \"hidden\",\n  \"top\": \"0\",\n  \"left\": \"0\",\n  \"bottom\": \"0\",\n  \"right\": \"0\"\n}\n\nMonocle.Styles.page = {\n  \"position\": \"absolute\",\n  \"z-index\": \"1\",\n  \"-webkit-user-select\": \"none\",\n  \"-moz-user-select\": \"none\",\n  \"-ms-user-select\": \"none\",\n  \"user-select\": \"none\",\n  \"-webkit-transform\": \"translate3d(0,0,0)\",\n  \"visibility\": \"visible\"\n\n  /*\n  \"background\": \"white\",\n  \"top\": \"0\",\n  \"left\": \"0\",\n  \"bottom\": \"0\",\n  \"right\": \"0\"\n  */\n}\n\nMonocle.Styles.sheaf = {\n  \"position\": \"absolute\",\n  \"overflow\": \"hidden\"\n\n  /*\n  \"top\": \"0\",\n  \"left\": \"0\",\n  \"bottom\": \"0\",\n  \"right\": \"0\"\n  */\n}\n\nMonocle.Styles.component = {\n  \"width\": \"100%\",\n  \"height\": \"100%\",\n  \"border\": \"none\",\n  \"-webkit-user-select\": \"none\",\n  \"-moz-user-select\": \"none\",\n  \"-ms-user-select\": \"none\",\n  \"user-select\": \"none\"\n}\n\nMonocle.Styles.control = {\n  \"z-index\": \"100\",\n  \"cursor\": \"pointer\"\n}\n\nMonocle.Styles.overlay = {\n  \"position\": \"absolute\",\n  \"display\": \"none\",\n  \"width\": \"100%\",\n  \"height\": \"100%\",\n  \"z-index\": \"1000\"\n}\n;\nMonocle.Formatting = function (reader, optStyles, optScale) {\n  var API = { constructor: Monocle.Formatting };\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    reader: reader,\n\n    // An array of style rules that are automatically applied to every page.\n    stylesheets: [],\n\n    // A multiplier on the default font-size of each element in every\n    // component. If null, the multiplier is not applied (or it is removed).\n    fontScale: null\n  }\n\n\n  function initialize() {\n    p.fontScale = optScale;\n    clampStylesheets(optStyles);\n    p.reader.listen('monocle:componentmodify', persistOnComponentChange);\n  }\n\n\n  // Clamp page frames to a set of styles that reduce Monocle breakage.\n  //\n  function clampStylesheets(implStyles) {\n    var defCSS = k.DEFAULT_STYLE_RULES;\n    if (Monocle.Browser.env.floatsIgnoreColumns) {\n      defCSS.push(\"html#RS\\\\:monocle * { float: none !important; }\");\n    }\n    p.defaultStyles = addPageStyles(defCSS, false);\n    if (implStyles) {\n      p.initialStyles = addPageStyles(implStyles, false);\n    }\n  }\n\n\n  function persistOnComponentChange(evt) {\n    var doc = evt.m['document'];\n    doc.documentElement.id = p.reader.properties.systemId;\n    adjustFontScaleForDoc(doc, p.fontScale);\n    for (var i = 0; i < p.stylesheets.length; ++i) {\n      if (p.stylesheets[i]) {\n        addPageStylesheet(doc, i);\n      }\n    }\n  }\n\n\n  /* PAGE STYLESHEETS */\n\n  // API for adding a new stylesheet to all components. styleRules should be\n  // a string of CSS rules. restorePlace defaults to true.\n  //\n  // Returns a sheet index value that can be used with updatePageStyles\n  // and removePageStyles.\n  //\n  function addPageStyles(styleRules, restorePlace) {\n    return changingStylesheet(function () {\n      p.stylesheets.push(styleRules);\n      var sheetIndex = p.stylesheets.length - 1;\n\n      var i = 0, cmpt = null;\n      while (cmpt = p.reader.dom.find('component', i++)) {\n        addPageStylesheet(cmpt.contentDocument, sheetIndex);\n      }\n      return sheetIndex;\n    }, restorePlace);\n  }\n\n\n  // API for updating the styleRules in an existing page stylesheet across\n  // all components. Takes a sheet index value obtained via addPageStyles.\n  //\n  function updatePageStyles(sheetIndex, styleRules, restorePlace) {\n    return changingStylesheet(function () {\n      p.stylesheets[sheetIndex] = styleRules;\n      if (typeof styleRules.join == \"function\") {\n        styleRules = styleRules.join(\"\\n\");\n      }\n\n      var i = 0, cmpt = null;\n      while (cmpt = p.reader.dom.find('component', i++)) {\n        var doc = cmpt.contentDocument;\n        var styleTag = doc.getElementById('monStylesheet'+sheetIndex);\n        if (!styleTag) {\n          console.warn('No such stylesheet: ' + sheetIndex);\n          return;\n        }\n        if (styleTag.styleSheet) {\n          styleTag.styleSheet.cssText = styleRules;\n        } else {\n          styleTag.replaceChild(\n            doc.createTextNode(styleRules),\n            styleTag.firstChild\n          );\n        }\n      }\n    }, restorePlace);\n  }\n\n\n  // API for removing a page stylesheet from all components. Takes a sheet\n  // index value obtained via addPageStyles.\n  //\n  function removePageStyles(sheetIndex, restorePlace) {\n    return changingStylesheet(function () {\n      p.stylesheets[sheetIndex] = null;\n      var i = 0, cmpt = null;\n      while (cmpt = p.reader.dom.find('component', i++)) {\n        var doc = cmpt.contentDocument;\n        var styleTag = doc.getElementById('monStylesheet'+sheetIndex);\n        styleTag.parentNode.removeChild(styleTag);\n      }\n    }, restorePlace);\n  }\n\n\n  // Wraps all API-based stylesheet changes (add, update, remove) in a\n  // brace of custom events (stylesheetchanging/stylesheetchange), and\n  // recalculates component dimensions if specified (default to true).\n  //\n  function changingStylesheet(callback, restorePlace) {\n    restorePlace = (restorePlace === false) ? false : true;\n    if (restorePlace) {\n      dispatchChanging();\n    }\n    var result = callback();\n    if (restorePlace) {\n      p.reader.recalculateDimensions(true);\n      Monocle.defer(dispatchChange);\n    } else {\n      p.reader.recalculateDimensions(false);\n    }\n    return result;\n  }\n\n\n  function dispatchChanging() {\n    p.reader.dispatchEvent(\"monocle:stylesheetchanging\", {});\n  }\n\n\n  function dispatchChange() {\n    p.reader.dispatchEvent(\"monocle:stylesheetchange\", {});\n  }\n\n\n  // Private method for adding a stylesheet to a component. Used by\n  // addPageStyles.\n  //\n  function addPageStylesheet(doc, sheetIndex) {\n    var styleRules = p.stylesheets[sheetIndex];\n\n    if (!styleRules) {\n      return;\n    }\n\n    if (!doc || !doc.documentElement) {\n      return;\n    }\n\n    var head = doc.getElementsByTagName('head')[0];\n    if (!head) {\n      head = doc.createElement('head');\n      doc.documentElement.appendChild(head);\n    }\n\n    if (typeof styleRules.join == \"function\") {\n      styleRules = styleRules.join(\"\\n\");\n    }\n\n    var styleTag = doc.createElement('style');\n    styleTag.type = 'text/css';\n    styleTag.id = \"monStylesheet\"+sheetIndex;\n    if (styleTag.styleSheet) {\n      styleTag.styleSheet.cssText = styleRules;\n    } else {\n      styleTag.appendChild(doc.createTextNode(styleRules));\n    }\n\n    head.appendChild(styleTag);\n\n    return styleTag;\n  }\n\n\n  /* FONT SCALING */\n\n  function setFontScale(scale, restorePlace) {\n    p.fontScale = scale;\n    if (restorePlace) {\n      dispatchChanging();\n    }\n    var i = 0, cmpt = null;\n    while (cmpt = p.reader.dom.find('component', i++)) {\n      adjustFontScaleForDoc(cmpt.contentDocument, scale);\n    }\n    if (restorePlace) {\n      p.reader.recalculateDimensions(true);\n      dispatchChange();\n    } else {\n      p.reader.recalculateDimensions(false);\n    }\n  }\n\n\n  function adjustFontScaleForDoc(doc, scale) {\n    var elems = doc.getElementsByTagName('*');\n    if (scale) {\n      scale = parseFloat(scale);\n      if (!doc.body.pfsSwept) {\n        sweepElements(doc, elems);\n      }\n\n      // Iterate over each element, applying scale to the original\n      // font-size. If a proportional font sizing is already applied to\n      // the element, update existing cssText, otherwise append new cssText.\n      //\n      for (var j = 0, jj = elems.length; j < jj; ++j) {\n        var newFs = fsProperty(elems[j].pfsOriginal, scale);\n        if (elems[j].pfsApplied) {\n          replaceFontSizeInStyle(elems[j], newFs);\n        } else {\n          elems[j].style.cssText += newFs;\n        }\n        elems[j].pfsApplied = scale;\n      }\n    } else if (doc.body.pfsSwept) {\n      // Iterate over each element, removing proportional font-sizing flag\n      // and property from cssText.\n      for (var j = 0, jj = elems.length; j < jj; ++j) {\n        if (elems[j].pfsApplied) {\n          var oprop = elems[j].pfsOriginalProp;\n          var opropDec = oprop ? 'font-size: '+oprop+' ! important;' : '';\n          replaceFontSizeInStyle(elems[j], opropDec);\n          elems[j].pfsApplied = null;\n        }\n      }\n\n      // Establish new baselines in case classes have changed.\n      sweepElements(doc, elems);\n    }\n  }\n\n\n  function sweepElements(doc, elems) {\n    // Iterate over each element, looking at its font size and storing\n    // the original value against the element.\n    for (var i = 0, ii = elems.length; i < ii; ++i) {\n      var currStyle = doc.defaultView.getComputedStyle(elems[i], null);\n      var fs = parseFloat(currStyle.getPropertyValue('font-size'));\n      elems[i].pfsOriginal = fs;\n      elems[i].pfsOriginalProp = elems[i].style.fontSize;\n    }\n    doc.body.pfsSwept = true;\n  }\n\n\n  function fsProperty(orig, scale) {\n    return 'font-size: '+(orig*scale)+'px ! important;';\n  }\n\n\n  function replaceFontSizeInStyle(elem, newProp) {\n    var lastFs = /font-size:[^;]/\n    elem.style.cssText = elem.style.cssText.replace(lastFs, newProp);\n  }\n\n\n  API.addPageStyles = addPageStyles;\n  API.updatePageStyles = updatePageStyles;\n  API.removePageStyles = removePageStyles;\n  API.setFontScale = setFontScale;\n\n  initialize();\n\n  return API;\n}\n\n\n\nMonocle.Formatting.DEFAULT_STYLE_RULES = [\n  \"html#RS\\\\:monocle * {\" +\n    \"-webkit-font-smoothing: subpixel-antialiased;\" +\n    \"text-rendering: auto !important;\" +\n    \"word-wrap: break-word !important;\" +\n    \"overflow: visible !important;\" +\n  \"}\",\n  \"html#RS\\\\:monocle body {\" +\n    \"margin: 0 !important;\"+\n    \"border: none !important;\" +\n    \"padding: 0 !important;\" +\n    \"width: 100% !important;\" +\n    \"position: absolute !important;\" +\n    \"-webkit-text-size-adjust: none;\" +\n  \"}\",\n  \"html#RS\\\\:monocle body * {\" +\n    \"max-width: 100% !important;\" +\n  \"}\",\n  \"html#RS\\\\:monocle img, html#RS\\\\:monocle video, html#RS\\\\:monocle object {\" +\n    \"max-height: 95% !important;\" +\n    \"height: auto !important;\" +\n  \"}\"\n]\n;\n// READER\n//\n//\n// The full DOM hierarchy created by Reader is:\n//\n//   box\n//    -> container\n//      -> pages (the number of page elements is determined by the flipper)\n//        -> sheaf (basically just sets the margins)\n//          -> component (an iframe created by the current component)\n//            -> body (the document.body of the iframe)\n//        -> page controls\n//      -> standard controls\n//    -> overlay\n//      -> modal/popover controls\n//\n//\n// Options:\n//\n//  flipper: The class of page flipper to use.\n//\n//  panels: The class of panels to use\n//\n//  stylesheet: A string of CSS rules to apply to the contents of each\n//    component loaded into the reader.\n//\n//  fontScale: a float to multiply against the default font-size of each\n//    element in each component.\n//\n//  place: A book locus for the page to open to when the reader is\n//    initialized. (See comments at Book#pageNumberAt for more about\n//    the locus option).\n//\n//  systemId: the id for root elements of components, defaults to \"RS:monocle\"\n//\nMonocle.Reader = function (node, bookData, options, onLoadCallback) {\n\n  var API = { constructor: Monocle.Reader }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    // Initialization-completed flag.\n    initialized: false,\n\n    // The active book.\n    book: null,\n\n    // DOM graph of factory-generated objects.\n    graph: {},\n\n    // Id applied to the HTML element of each component, can be used to scope\n    // CSS rules.\n    systemId: (options ? options.systemId : null) || k.DEFAULT_SYSTEM_ID,\n\n    // Prefix for classnames for any created element.\n    classPrefix: k.DEFAULT_CLASS_PREFIX,\n\n    // Registered control objects (see addControl). Hashes of the form:\n    //   {\n    //     control: <control instance>,\n    //     elements: <array of topmost elements created by control>,\n    //     controlType: <standard, page, modal, popover, invisible, etc>\n    //   }\n    controls: [],\n\n    // After the reader has been resized, this resettable timer must expire\n    // the place is restored.\n    resizeTimer: null\n  }\n\n  var dom;\n\n\n  // Inspects the browser environment and kicks off preparing the container.\n  //\n  function initialize() {\n    options = options || {}\n\n    Monocle.Browser.survey(prepareBox);\n  }\n\n\n  // Sets up the container and internal elements.\n  //\n  function prepareBox() {\n    var box = node;\n    if (typeof box == \"string\") { box = document.getElementById(box); }\n    dom = API.dom = box.dom = new Monocle.Factory(box, 'box', 0, API);\n\n    API.billboard = new Monocle.Billboard(API);\n\n    if (!Monocle.Browser.env.isCompatible()) {\n      if (dispatchEvent(\"monocle:incompatible\", {}, true)) {\n        API.billboard.show(k.SUPPORT_URL, { closeButton: false });\n      }\n      return;\n    }\n\n    dispatchEvent(\"monocle:initializing\", API);\n\n    bookData = bookData || Monocle.bookDataFromNodes([box.cloneNode(true)]);\n    var bk = new Monocle.Book(bookData, options.preloadWindow || 1);\n\n    box.innerHTML = \"\";\n\n    // Make sure the box div is absolutely or relatively positioned.\n    positionBox();\n\n    // Attach the page-flipping gadget.\n    attachFlipper(options.flipper);\n\n    // Create the essential DOM elements.\n    createReaderElements();\n\n    // Create the selection object.\n    API.selection = new Monocle.Selection(API);\n\n    // Create the formatting object.\n    API.formatting = new Monocle.Formatting(\n      API,\n      options.stylesheet,\n      options.fontScale\n    );\n\n    primeFrames(options.primeURL, function () {\n      // Make the reader elements look pretty.\n      applyStyles();\n\n      p.flipper.listenForInteraction(options.panels);\n\n      setBook(bk, options.place, function () {\n        p.initialized = true;\n        if (onLoadCallback) { onLoadCallback(API); }\n        dispatchEvent(\"monocle:loaded\", API);\n      });\n    });\n  }\n\n\n  function positionBox() {\n    var currPosVal;\n    var box = dom.find('box');\n    if (document.defaultView) {\n      var currStyle = document.defaultView.getComputedStyle(box, null);\n      currPosVal = currStyle.getPropertyValue('position');\n    } else if (box.currentStyle) {\n      currPosVal = box.currentStyle.position\n    }\n    if ([\"absolute\", \"relative\"].indexOf(currPosVal) == -1) {\n      box.style.position = \"relative\";\n    }\n  }\n\n\n  function attachFlipper(flipperClass) {\n    if (!flipperClass) {\n      if (Monocle.Browser.renders.eInk || Monocle.Browser.renders.slow) {\n        flipperClass = Monocle.Flippers.Instant;\n      } else {\n        flipperClass = Monocle.Flippers.Slider;\n      }\n    }\n\n    p.flipper = new flipperClass(API, null, p.readerOptions);\n  }\n\n\n  function createReaderElements() {\n    var cntr = dom.append('div', 'container');\n    for (var i = 0; i < p.flipper.pageCount; ++i) {\n      var page = cntr.dom.append('div', 'page', i);\n      page.style.visibility = \"hidden\";\n      page.m = { reader: API, pageIndex: i, place: null }\n      page.m.sheafDiv = page.dom.append('div', 'sheaf', i);\n      page.m.activeFrame = page.m.sheafDiv.dom.append('iframe', 'component', i);\n      page.m.activeFrame.m = { 'pageDiv': page };\n      page.m.activeFrame.setAttribute('frameBorder', 0);\n      page.m.activeFrame.setAttribute('scrolling', 'no');\n      p.flipper.addPage(page);\n    }\n    dom.append('div', 'overlay');\n    dispatchEvent(\"monocle:loading\", API);\n  }\n\n\n  // Opens the frame to a particular URL (usually 'about:blank').\n  //\n  function primeFrames(url, callback) {\n    url = url || (Monocle.Browser.on.UIWebView ? \"blank.html\" : \"about:blank\");\n\n    var pageCount = 0;\n\n    var cb = function (evt) {\n      var frame = evt.target || evt.srcElement;\n      Monocle.Events.deafen(frame, 'load', cb);\n      dispatchEvent(\n        'monocle:frameprimed',\n        { frame: frame, pageIndex: pageCount }\n      );\n      if ((pageCount += 1) == p.flipper.pageCount) {\n        Monocle.defer(callback);\n      }\n    }\n\n    forEachPage(function (page) {\n      Monocle.Events.listen(page.m.activeFrame, 'load', cb);\n      page.m.activeFrame.src = url;\n    });\n  }\n\n\n  function applyStyles() {\n    dom.find('container').dom.setStyles(Monocle.Styles.container);\n    forEachPage(function (page, i) {\n      page.dom.setStyles(Monocle.Styles.page);\n      dom.find('sheaf', i).dom.setStyles(Monocle.Styles.sheaf);\n      var cmpt = dom.find('component', i)\n      cmpt.dom.setStyles(Monocle.Styles.component);\n    });\n    lockFrameWidths();\n    dom.find('overlay').dom.setStyles(Monocle.Styles.overlay);\n    dispatchEvent('monocle:styles');\n  }\n\n\n  function lockingFrameWidths() {\n    if (!Monocle.Browser.env.relativeIframeExpands) { return; }\n    for (var i = 0, cmpt; cmpt = dom.find('component', i); ++i) {\n      cmpt.style.display = \"none\";\n    }\n  }\n\n\n  function lockFrameWidths() {\n    if (!Monocle.Browser.env.relativeIframeExpands) { return; }\n    for (var i = 0, cmpt; cmpt = dom.find('component', i); ++i) {\n      cmpt.style.width = cmpt.parentNode.offsetWidth+\"px\";\n      cmpt.style.display = \"block\";\n    }\n  }\n\n\n  // Apply the book, move to a particular place or just the first page, wait\n  // for everything to complete, then fire the callback.\n  //\n  function setBook(bk, place, callback) {\n    p.book = bk;\n    var pageCount = 0;\n    if (typeof callback == 'function') {\n      var watchers = {\n        'monocle:componentchange': function (evt) {\n          dispatchEvent('monocle:firstcomponentchange', evt.m);\n          return (pageCount += 1) == p.flipper.pageCount;\n        },\n        'monocle:turn': function (evt) {\n          callback();\n          return true;\n        }\n      }\n      var listener = function (evt) {\n        if (watchers[evt.type](evt)) { deafen(evt.type, listener); }\n      }\n      for (evtType in watchers) { listen(evtType, listener) }\n    }\n    p.flipper.moveTo(place || { page: 1 });\n  }\n\n\n  function getBook() {\n    return p.book;\n  }\n\n\n  // Attempts to restore the place we were up to in the book before the\n  // reader was resized.\n  //\n  function resized() {\n    if (!p.initialized) {\n      console.warn('Attempt to resize book before initialization.');\n    }\n    lockingFrameWidths();\n    if (!dispatchEvent(\"monocle:resizing\", {}, true)) {\n      return;\n    }\n    clearTimeout(p.resizeTimer);\n    p.resizeTimer = setTimeout(\n      function () {\n        lockFrameWidths();\n        recalculateDimensions(true);\n        dispatchEvent(\"monocle:resize\");\n      },\n      k.RESIZE_DELAY\n    );\n  }\n\n\n  function recalculateDimensions(andRestorePlace) {\n    if (!p.book) { return; }\n    dispatchEvent(\"monocle:recalculating\");\n\n    var place, locus;\n    if (andRestorePlace !== false) {\n      var place = getPlace();\n      var locus = { percent: place ? place.percentageThrough() : 0 };\n    }\n\n    // Better to use an event? Or chaining consecutively?\n    forEachPage(function (pageDiv) {\n      pageDiv.m.activeFrame.m.component.updateDimensions(pageDiv);\n    });\n\n    Monocle.defer(function () {\n      if (locus) { p.flipper.moveTo(locus); }\n      dispatchEvent(\"monocle:recalculated\");\n    });\n  }\n\n\n  // Returns the current page number in the book.\n  //\n  // The pageDiv argument is optional - typically defaults to whatever the\n  // flipper thinks is the \"active\" page.\n  //\n  function pageNumber(pageDiv) {\n    var place = getPlace(pageDiv);\n    return place ? (place.pageNumber() || 1) : 1;\n  }\n\n\n  // Returns the current \"place\" in the book -- ie, the page number, chapter\n  // title, etc.\n  //\n  // The pageDiv argument is optional - typically defaults to whatever the\n  // flipper thinks is the \"active\" page.\n  //\n  function getPlace(pageDiv) {\n    if (!p.initialized) {\n      console.warn('Attempt to access place before initialization.');\n    }\n    return p.flipper.getPlace(pageDiv);\n  }\n\n\n  // Moves the current page as specified by the locus. See\n  // Monocle.Book#pageNumberAt for documentation on the locus argument.\n  //\n  // The callback argument is optional.\n  //\n  function moveTo(locus, callback) {\n    if (!p.initialized) {\n      console.warn('Attempt to move place before initialization.');\n    }\n    if (!p.book.isValidLocus(locus)) {\n      dispatchEvent(\n        \"monocle:notfound\",\n        { href: locus ? locus.componentId : \"anonymous\" }\n      );\n      return false;\n    }\n    var fn = callback;\n    if (!locus.direction) {\n      dispatchEvent('monocle:jumping', { locus: locus });\n      fn = function () {\n        dispatchEvent('monocle:jump', { locus: locus });\n        if (callback) { callback(); }\n      }\n    }\n    p.flipper.moveTo(locus, fn);\n    return true;\n  }\n\n\n  // Moves to the relevant element in the relevant component.\n  //\n  function skipToChapter(src) {\n    var locus = p.book.locusOfChapter(src);\n    return moveTo(locus);\n  }\n\n\n  // Valid types:\n  //  - standard (an overlay above the pages)\n  //  - page (within the page)\n  //  - modal (overlay where click-away does nothing, for a single control)\n  //  - hud (overlay that multiple controls can share)\n  //  - popover (overlay where click-away removes the ctrl elements)\n  //  - invisible\n  //\n  // Options:\n  //  - hidden -- creates and hides the ctrl elements;\n  //              use showControl to show them\n  //\n  function addControl(ctrl, cType, options) {\n    for (var i = 0; i < p.controls.length; ++i) {\n      if (p.controls[i].control == ctrl) {\n        console.warn(\"Already added control: %o\", ctrl);\n        return;\n      }\n    }\n\n    options = options || {};\n\n    var ctrlData = {\n      control: ctrl,\n      elements: [],\n      controlType: cType\n    }\n    p.controls.push(ctrlData);\n\n    var ctrlElem;\n    var cntr = dom.find('container'), overlay = dom.find('overlay');\n    if (!cType || cType == \"standard\") {\n      ctrlElem = ctrl.createControlElements(cntr);\n      cntr.appendChild(ctrlElem);\n      ctrlData.elements.push(ctrlElem);\n    } else if (cType == \"page\") {\n      forEachPage(function (page, i) {\n        var runner = ctrl.createControlElements(page);\n        page.appendChild(runner);\n        ctrlData.elements.push(runner);\n      });\n    } else if (cType == \"modal\" || cType == \"popover\" || cType == \"hud\") {\n      ctrlElem = ctrl.createControlElements(overlay);\n      overlay.appendChild(ctrlElem);\n      ctrlData.elements.push(ctrlElem);\n      ctrlData.usesOverlay = true;\n    } else if (cType == \"invisible\") {\n      if (\n        typeof(ctrl.createControlElements) == \"function\" &&\n        (ctrlElem = ctrl.createControlElements(cntr))\n      ) {\n        cntr.appendChild(ctrlElem);\n        ctrlData.elements.push(ctrlElem);\n      }\n    } else {\n      console.warn(\"Unknown control type: \" + cType);\n    }\n\n    for (var i = 0; i < ctrlData.elements.length; ++i) {\n      Monocle.Styles.applyRules(ctrlData.elements[i], Monocle.Styles.control);\n    }\n\n    if (options.hidden) {\n      hideControl(ctrl);\n    } else {\n      showControl(ctrl);\n    }\n\n    if (typeof ctrl.assignToReader == 'function') {\n      ctrl.assignToReader(API);\n    }\n\n    return ctrl;\n  }\n\n\n  function dataForControl(ctrl) {\n    for (var i = 0; i < p.controls.length; ++i) {\n      if (p.controls[i].control == ctrl) {\n        return p.controls[i];\n      }\n    }\n  }\n\n\n  function hideControl(ctrl) {\n    var controlData = dataForControl(ctrl);\n    if (!controlData) {\n      console.warn(\"No data for control: \" + ctrl);\n      return;\n    }\n    if (controlData.hidden) {\n      return;\n    }\n    for (var i = 0; i < controlData.elements.length; ++i) {\n      controlData.elements[i].style.display = \"none\";\n    }\n    if (controlData.usesOverlay) {\n      var overlay = dom.find('overlay');\n      overlay.style.display = \"none\";\n      Monocle.Events.deafenForContact(overlay, overlay.listeners);\n      if (controlData.controlType != 'hud') {\n        dispatchEvent('monocle:modal:off');\n      }\n    }\n    controlData.hidden = true;\n    if (ctrl.properties) {\n      ctrl.properties.hidden = true;\n    }\n    dispatchEvent('monocle:controlhide', { control: ctrl }, false);\n  }\n\n\n  function showControl(ctrl) {\n    var controlData = dataForControl(ctrl);\n    if (!controlData) {\n      console.warn(\"No data for control: \" + ctrl);\n      return false;\n    }\n\n    if (showingControl(ctrl)) {\n      return false;\n    }\n\n    var overlay = dom.find('overlay');\n    if (controlData.usesOverlay && controlData.controlType != \"hud\") {\n      for (var i = 0, ii = p.controls.length; i < ii; ++i) {\n        if (p.controls[i].usesOverlay && !p.controls[i].hidden) {\n          return false;\n        }\n      }\n      overlay.style.display = \"block\";\n      dispatchEvent('monocle:modal:on');\n    }\n\n    for (var i = 0; i < controlData.elements.length; ++i) {\n      controlData.elements[i].style.display = \"block\";\n    }\n\n    if (controlData.controlType == \"popover\") {\n      var onControl = function (evt) {\n        var obj = evt.target;\n        do {\n          if (obj == controlData.elements[0]) { return true; }\n        } while (obj && (obj = obj.parentNode));\n        return false;\n      }\n      overlay.listeners = Monocle.Events.listenForContact(\n        overlay,\n        {\n          start: function (evt) { if (!onControl(evt)) { hideControl(ctrl); } },\n          move: function (evt) { if (!onControl(evt)) { evt.preventDefault(); } }\n        }\n      );\n    }\n    controlData.hidden = false;\n    if (ctrl.properties) {\n      ctrl.properties.hidden = false;\n    }\n    dispatchEvent('monocle:controlshow', { control: ctrl }, false);\n    return true;\n  }\n\n\n  function showingControl(ctrl) {\n    var controlData = dataForControl(ctrl);\n    return controlData.hidden == false;\n  }\n\n\n  function dispatchEvent(evtType, data, cancelable) {\n    return Monocle.Events.dispatch(dom.find('box'), evtType, data, cancelable);\n  }\n\n\n  function listen(evtType, fn, useCapture) {\n    Monocle.Events.listen(dom.find('box'), evtType, fn, useCapture);\n  }\n\n\n  function deafen(evtType, fn) {\n    Monocle.Events.deafen(dom.find('box'), evtType, fn);\n  }\n\n\n  function visiblePages() {\n    return p.flipper.visiblePages ?\n      p.flipper.visiblePages() :\n      [dom.find('page')];\n  }\n\n\n  function forEachPage(callback) {\n    for (var i = 0, ii = p.flipper.pageCount; i < ii; ++i) {\n      var page = dom.find('page', i);\n      callback(page, i);\n    }\n  }\n\n\n  /* The Reader PageStyles API is deprecated - it has moved to Formatting */\n\n  function addPageStyles(styleRules, restorePlace) {\n    console.deprecation(\"Use reader.formatting.addPageStyles instead.\");\n    return API.formatting.addPageStyles(styleRules, restorePlace);\n  }\n\n\n  function updatePageStyles(sheetIndex, styleRules, restorePlace) {\n    console.deprecation(\"Use reader.formatting.updatePageStyles instead.\");\n    return API.formatting.updatePageStyles(sheetIndex, styleRules, restorePlace);\n  }\n\n\n  function removePageStyles(sheetIndex, restorePlace) {\n    console.deprecation(\"Use reader.formatting.removePageStyles instead.\");\n    return API.formatting.removePageStyles(sheetIndex, restorePlace);\n  }\n\n\n  API.getBook = getBook;\n  API.getPlace = getPlace;\n  API.moveTo = moveTo;\n  API.skipToChapter = skipToChapter;\n  API.resized = resized;\n  API.recalculateDimensions = recalculateDimensions;\n  API.addControl = addControl;\n  API.hideControl = hideControl;\n  API.showControl = showControl;\n  API.showingControl = showingControl;\n  API.dispatchEvent = dispatchEvent;\n  API.listen = listen;\n  API.deafen = deafen;\n  API.visiblePages = visiblePages;\n\n  // Deprecated!\n  API.addPageStyles = addPageStyles;\n  API.updatePageStyles = updatePageStyles;\n  API.removePageStyles = removePageStyles;\n\n  initialize();\n\n  return API;\n}\n\n\n\nMonocle.Reader.SUPPORT_URL = 'http://unsupported.monoclejs.com';\nMonocle.Reader.RESIZE_DELAY = 100;\nMonocle.Reader.DEFAULT_SYSTEM_ID = 'RS:monocle'\nMonocle.Reader.DEFAULT_CLASS_PREFIX = 'monelem_'\nMonocle.Reader.DEFAULT_STYLE_RULES = Monocle.Formatting.DEFAULT_STYLE_RULES;\n/* BOOK */\n\n/* The Book handles movement through the content by the reader page elements.\n *\n * It's responsible for instantiating components as they are required,\n * and for calculating which component and page number to move to (based on\n * requests from the Reader).\n *\n * It should set and know the place of each page element too.\n *\n */\n\nMonocle.Book = function (dataSource, preloadWindow) {\n\n  var API = { constructor: Monocle.Book }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    dataSource: dataSource,\n    preloadWindow: preloadWindow,\n    cmptLoadQueue: {},\n    components: [],\n    chapters: {} // flat arrays of chapters per component\n  }\n\n\n  function initialize() {\n    p.componentIds = dataSource.getComponents();\n    p.contents = dataSource.getContents();\n    p.lastCIndex = p.componentIds.length - 1;\n  }\n\n\n  // Adjusts the given locus object to provide the page number within the\n  // current component.\n  //\n  // If the locus implies movement to another component, the locus\n  // 'componentId' property will be updated to point to this component, and\n  // the 'load' property will be set to true, which should be taken as a\n  // sign to call loadPageAt with a callback.\n  //\n  // The locus argument is an object that has one of the following properties:\n  //\n  //  - page: positive integer. Counting up from the start of component.\n  //  - pagesBack: negative integer. Counting back from the end of component.\n  //  - percent: float\n  //  - direction: integer relative to the current page number for this pageDiv\n  //  - position: string, one of \"start\" or \"end\", moves to corresponding point\n  //      in the given component\n  //  - anchor: an element id within the component\n  //  - xpath: the node at this XPath within the component\n  //  - selector: the first node at this CSS selector within the component\n  //\n  // The locus object can also specify a componentId. If it is not provided\n  // we default to the currently active component, and if that doesn't exist,\n  // we default to the very first component.\n  //\n  // The locus result will be an object with the following properties:\n  //\n  //  - load: boolean, true if loading component required, false otherwise\n  //  - componentId: component to load (current componentId if load is false)\n  //  - if load is false:\n  //    - page\n  //  - if load is true:\n  //    - one of page / pagesBack / percent / direction / position / anchor\n  //\n  function pageNumberAt(pageDiv, locus) {\n    locus.load = false;\n    var currComponent = pageDiv.m.activeFrame ?\n      pageDiv.m.activeFrame.m.component :\n      null;\n    var component = null;\n    var cIndex = p.componentIds.indexOf(locus.componentId);\n    if (cIndex < 0 && !currComponent) {\n      // No specified component, no current component. Load first component.\n      locus.load = true;\n      locus.componentId = p.componentIds[0];\n      return locus;\n    } else if (\n      cIndex < 0 &&\n      locus.componentId &&\n      currComponent.properties.id != locus.componentId\n    ) {\n      // Invalid component, say not found.\n      pageDiv.m.reader.dispatchEvent(\n        \"monocle:notfound\",\n        { href: locus.componentId }\n      );\n      return null;\n    } else if (cIndex < 0) {\n      // No specified (or invalid) component, use current component.\n      component = currComponent;\n      locus.componentId = pageDiv.m.activeFrame.m.component.properties.id;\n      cIndex = p.componentIds.indexOf(locus.componentId);\n    } else if (!p.components[cIndex] || p.components[cIndex] != currComponent) {\n      // Specified component differs from current component. Load specified.\n      locus.load = true;\n      return locus;\n    } else {\n      component = currComponent;\n    }\n\n    // If we're here, then the locus is based on the current component.\n    var result = { load: false, componentId: locus.componentId, page: 1 }\n\n    // Get the current last page.\n    lastPageNum = component.lastPageNumber();\n\n    // Deduce the page number for the given locus.\n    if (typeof(locus.page) == \"number\") {\n      result.page = locus.page;\n    } else if (typeof(locus.pagesBack) == \"number\") {\n      result.page = lastPageNum + locus.pagesBack;\n    } else if (typeof(locus.percent) == \"number\") {\n      var place = new Monocle.Place();\n      place.setPlace(component, 1);\n      result.page = place.pageAtPercentageThrough(locus.percent);\n    } else if (typeof(locus.direction) == \"number\") {\n      if (!pageDiv.m.place) {\n        console.warn(\"Can't move in a direction if pageDiv has no place.\");\n      }\n      result.page = pageDiv.m.place.pageNumber();\n      result.page += locus.direction;\n    } else if (typeof(locus.anchor) == \"string\") {\n      result.page = component.pageForChapter(locus.anchor, pageDiv);\n    } else if (typeof(locus.xpath) == \"string\") {\n      result.page = component.pageForXPath(locus.xpath, pageDiv);\n    } else if (typeof(locus.selector) == \"string\") {\n      result.page = component.pageForSelector(locus.selector, pageDiv);\n    } else if (typeof(locus.position) == \"string\") {\n      if (locus.position == \"start\") {\n        result.page = 1;\n      } else if (locus.position == \"end\") {\n        result.page = lastPageNum['new'];\n      }\n    } else {\n      console.warn(\"Unrecognised locus: \" + locus);\n    }\n\n    if (result.page < 1) {\n      if (cIndex == 0) {\n        // On first page of book.\n        result.page = 1;\n        result.boundarystart = true;\n      } else {\n        // Moving backwards from current component.\n        result.load = true;\n        result.componentId = p.componentIds[cIndex - 1];\n        result.pagesBack = result.page;\n        result.page = null;\n      }\n    } else if (result.page > lastPageNum) {\n      if (cIndex == p.lastCIndex) {\n        // On last page of book.\n        result.page = lastPageNum;\n        result.boundaryend = true;\n      } else {\n        // Moving forwards from current component.\n        result.load = true;\n        result.componentId = p.componentIds[cIndex + 1];\n        result.page -= lastPageNum;\n      }\n    }\n\n    return result;\n  }\n\n\n  // Same as pageNumberAt, but if a load is not flagged, this will\n  // automatically update the pageDiv's place to the given pageNumber.\n  //\n  // If you call this (ie, from a flipper), you are effectively entering into\n  // a contract to move the frame offset to the given page returned in the\n  // locus if load is false.\n  //\n  function setPageAt(pageDiv, locus) {\n    locus = pageNumberAt(pageDiv, locus);\n    if (locus && !locus.load) {\n      var evtData = { locus: locus, page: pageDiv }\n      if (locus.boundarystart) {\n        pageDiv.m.reader.dispatchEvent('monocle:boundarystart', evtData);\n      } else if (locus.boundaryend) {\n        pageDiv.m.reader.dispatchEvent('monocle:boundaryend', evtData);\n      } else {\n        var component = p.components[p.componentIds.indexOf(locus.componentId)];\n        pageDiv.m.place = pageDiv.m.place || new Monocle.Place();\n        pageDiv.m.place.setPlace(component, locus.page);\n\n        var evtData = {\n          page: pageDiv,\n          locus: locus,\n          pageNumber: pageDiv.m.place.pageNumber(),\n          componentId: locus.componentId\n        }\n        pageDiv.m.reader.dispatchEvent(\"monocle:pagechange\", evtData);\n      }\n    }\n    return locus;\n  }\n\n\n  // Will load the given component into the pageDiv's frame, then invoke the\n  // callback with resulting locus (provided by pageNumberAt).\n  //\n  // If the resulting page number is outside the bounds of the new component,\n  // (ie, pageNumberAt again requests a load), this will recurse into further\n  // components until non-loading locus is returned by pageNumberAt. Then the\n  // callback will fire with that locus.\n  //\n  // As with setPageAt, if you call this you're obliged to move the frame\n  // offset to the given page in the locus passed to the callback.\n  //\n  // If you pass a function as the progressCallback argument, the logic of this\n  // function will be in your control. The function will be invoked between:\n  //\n  // a) loading the component and\n  // b) applying the component to the frame and\n  // c) loading any further components if required\n  //\n  // with a function argument that performs the next step in the process. So\n  // if you need to do some special handling during the load process, you can.\n  //\n  function loadPageAt(pageDiv, locus, callback, progressCallback) {\n    var cIndex = p.componentIds.indexOf(locus.componentId);\n    if (!locus.load || cIndex < 0) {\n      locus = pageNumberAt(pageDiv, locus);\n    }\n\n    if (!locus) {\n      return;\n    }\n\n    if (!locus.load) {\n      callback(locus);\n      return;\n    }\n\n    var findPageNumber = function () {\n      locus = setPageAt(pageDiv, locus);\n      if (!locus) {\n        return;\n      } else if (locus.load) {\n        loadPageAt(pageDiv, locus, callback, progressCallback)\n      } else {\n        callback(locus);\n      }\n    }\n\n    var pgFindPageNumber = function () {\n      progressCallback ? progressCallback(findPageNumber) : findPageNumber();\n    }\n\n    var applyComponent = function (component) {\n      component.applyTo(pageDiv, pgFindPageNumber);\n      for (var l = 1; l <= p.preloadWindow; ++l) {\n        deferredPreloadComponent(cIndex+l, l*k.PRELOAD_INTERVAL);\n      }\n    }\n\n    var pgApplyComponent = function (component) {\n      progressCallback ?\n        progressCallback(function () { applyComponent(component) }) :\n        applyComponent(component);\n    }\n\n    loadComponent(cIndex, pgApplyComponent, pageDiv);\n  }\n\n\n  // If your flipper doesn't care whether a component needs to be\n  // loaded before the page can be set, you can use this shortcut.\n  //\n  function setOrLoadPageAt(pageDiv, locus, callback, onProgress, onFail) {\n    locus = setPageAt(pageDiv, locus);\n    if (!locus) {\n      if (onFail) { onFail(); }\n    } else if (locus.load) {\n      loadPageAt(pageDiv, locus, callback, onProgress);\n    } else {\n      callback(locus);\n    }\n  }\n\n\n  // Fetches the component source from the dataSource.\n  //\n  // 'index' is the index of the component in the\n  // dataSource.getComponents array.\n  //\n  // 'callback' is invoked when the source is received.\n  //\n  // 'pageDiv' is optional, and simply allows firing events on\n  // the reader object that has requested this component, ONLY if\n  // the source has not already been received.\n  //\n  function loadComponent(index, successCallback, pageDiv) {\n    if (p.components[index]) {\n      return successCallback(p.components[index]);\n    }\n\n    var cmptId = p.components[index];\n    var evtData = { 'page': pageDiv, 'component': cmptId, 'index': index };\n    pageDiv.m.reader.dispatchEvent('monocle:componentloading', evtData);\n\n    var onCmptLoad = function (cmpt) {\n      evtData['component'] = cmpt;\n      pageDiv.m.reader.dispatchEvent('monocle:componentloaded', evtData);\n      successCallback(cmpt);\n    }\n\n    var onCmptFail = function () {\n      console.warn(\"Failed to load component: \"+cmptId);\n      pageDiv.m.reader.dispatchEvent('monocle:componentfailed', evtData);\n      try {\n        var currCmpt = pageDiv.m.activeFrame.m.component;\n        evtData.cmptId = currCmpt.properties.id;\n        successCallback(currCmpt);\n      } catch (e) {\n        console.warn(\"Failed to fall back to previous component.\");\n      }\n    }\n\n    _loadComponent(index, onCmptLoad, onCmptFail);\n  }\n\n\n  function preloadComponent(index) {\n    if (p.components[index]) { return; }\n    var cmptId = p.componentIds[index];\n    if (!cmptId) { return; }\n    if (p.cmptLoadQueue[cmptId]) { return; }\n    _loadComponent(index);\n  }\n\n\n  function deferredPreloadComponent(index, delay) {\n    Monocle.defer(function () { preloadComponent(index); }, delay);\n  }\n\n\n  function _loadComponent(index, successCallback, failureCallback) {\n    var cmptId = p.componentIds[index];\n    var queueItem = { success: successCallback, failure: failureCallback };\n    if (p.cmptLoadQueue[cmptId]) {\n      return p.cmptLoadQueue[cmptId] = queueItem;\n    } else {\n      p.cmptLoadQueue[cmptId] = queueItem;\n    }\n\n    var onCmptFail = function () {\n      fireLoadQueue(cmptId, 'failure');\n    }\n\n    var onCmptLoad = function (cmptSource) {\n      if (cmptSource === false) { return onCmptFail(); }\n      p.components[index] = new Monocle.Component(\n        API,\n        cmptId,\n        index,\n        chaptersForComponent(cmptId),\n        cmptSource\n      );\n      fireLoadQueue(cmptId, 'success', p.components[index]);\n    }\n\n    var cmptSource = p.dataSource.getComponent(cmptId, onCmptLoad);\n    if (cmptSource && !p.components[index]) {\n      onCmptLoad(cmptSource);\n    } else if (cmptSource === false) {\n      onCmptFail();\n    }\n  }\n\n\n  function fireLoadQueue(cmptId, cbName, args) {\n    if (typeof p.cmptLoadQueue[cmptId][cbName] == 'function') {\n      p.cmptLoadQueue[cmptId][cbName](args);\n    }\n    p.cmptLoadQueue[cmptId] = null;\n  }\n\n\n  // Returns an array of chapter objects that are found in the given component.\n  //\n  // A chapter object has this format:\n  //\n  //    {\n  //      title: \"Chapter 1\",\n  //      fragment: null\n  //    }\n  //\n  // The fragment property of a chapter object is either null (the chapter\n  // starts at the head of the component) or the fragment part of the URL\n  // (eg, \"foo\" in \"index.html#foo\").\n  //\n  function chaptersForComponent(cmptId) {\n    if (p.chapters[cmptId]) {\n      return p.chapters[cmptId];\n    }\n    p.chapters[cmptId] = [];\n    var matcher = new RegExp('^'+decodeURIComponent(cmptId)+\"(\\#(.+)|$)\");\n    var matches;\n    var recurser = function (chp) {\n      if (matches = decodeURIComponent(chp.src).match(matcher)) {\n        p.chapters[cmptId].push({\n          title: chp.title,\n          fragment: matches[2] || null\n        });\n      }\n      if (chp.children) {\n        for (var i = 0; i < chp.children.length; ++i) {\n          recurser(chp.children[i]);\n        }\n      }\n    }\n\n    for (var i = 0; i < p.contents.length; ++i) {\n      recurser(p.contents[i]);\n    }\n    return p.chapters[cmptId];\n  }\n\n\n  // Returns a locus for the chapter that has the URL given in the\n  // 'src' argument.\n  //\n  // See the comments at pageNumberAt for an explanation of locus objects.\n  //\n  function locusOfChapter(src) {\n    var matcher = new RegExp('^(.+?)(#(.*))?$');\n    var matches = src.match(matcher);\n    if (!matches) { return null; }\n    var cmptId = componentIdMatching(matches[1]);\n    if (!cmptId) { return null; }\n    var locus = { componentId: cmptId }\n    matches[3] ? locus.anchor = matches[3] : locus.position = \"start\";\n    return locus;\n  }\n\n\n  function isValidLocus(locus) {\n    if (!locus) { return false; }\n    if (locus.componentId && !componentIdMatching(locus.componentId)) {\n      return false;\n    }\n    return true;\n  }\n\n\n  function componentIdMatching(str) {\n    str = decodeURIComponent(str);\n    for (var i = 0, ii = p.componentIds.length; i < ii; ++i) {\n      if (decodeURIComponent(p.componentIds[i]) == str) { return str; }\n    }\n    return null;\n  }\n\n\n  function componentWeights() {\n    if (!p.weights) {\n      p.weights = dataSource.getMetaData('componentWeights') || [];\n      if (!p.weights.length) {\n        var cmptSize = 1.0 / p.componentIds.length;\n        for (var i = 0, ii = p.componentIds.length; i < ii; ++i) {\n          p.weights.push(cmptSize);\n        }\n      }\n    }\n    return p.weights;\n  }\n\n\n  API.getMetaData = dataSource.getMetaData;\n  API.pageNumberAt = pageNumberAt;\n  API.setPageAt = setPageAt;\n  API.loadPageAt = loadPageAt;\n  API.setOrLoadPageAt = setOrLoadPageAt;\n  API.chaptersForComponent = chaptersForComponent;\n  API.locusOfChapter = locusOfChapter;\n  API.isValidLocus = isValidLocus;\n  API.componentWeights = componentWeights;\n\n  initialize();\n\n  return API;\n}\n\n\n// Legacy function. Deprecated.\n//\nMonocle.Book.fromNodes = function (nodes) {\n  console.deprecation(\"Book.fromNodes() will soon be removed.\");\n  return new Monocle.Book(Monocle.bookDataFromNodes(nodes));\n}\n\nMonocle.Book.PRELOAD_INTERVAL = 1000;\n// PLACE\n\nMonocle.Place = function () {\n\n  var API = { constructor: Monocle.Place }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    component: null,\n    percent: null\n  }\n\n\n  function setPlace(cmpt, pageN) {\n    p.component = cmpt;\n    p.percent = pageN / cmpt.lastPageNumber();\n    p.chapter = null;\n  }\n\n\n  function setPercentageThrough(cmpt, percent) {\n    p.component = cmpt;\n    p.percent = percent;\n    p.chapter = null;\n  }\n\n\n  function componentId() {\n    return p.component.properties.id;\n  }\n\n\n  // How far we are through the component at the \"top of the page\".\n  //\n  // 0 - start of book. 1.0 - end of book.\n  //\n  function percentAtTopOfPage() {\n    if (k.PAGE_ANCHOR == 'bottom') {\n      return p.percent - 1.0 / p.component.lastPageNumber();\n    } else {\n      return p.percent;\n    }\n  }\n\n\n  function percentOnPage() {\n    return percentAtTopOfPage() + k.PAGE_ANCHOR_OFFSET / pagesInComponent();\n  }\n\n\n  // How far we are through the component at the \"bottom of the page\".\n  //\n  function percentAtBottomOfPage() {\n    if (k.PAGE_ANCHOR == 'bottom') {\n      return p.percent;\n    } else {\n      return p.percent + 1.0 / p.component.lastPageNumber();\n    }\n  }\n\n\n  // The page number at a given point (0: start, 1: end) within the component.\n  //\n  function pageAtPercentageThrough(percent) {\n    var pages = pagesInComponent();\n    if (typeof percent != 'number') { percent = 0; }\n    return Math.max(Math.round(pages * percent), 1);\n  }\n\n\n  // The page number of this point within the component.\n  //\n  function pageNumber() {\n    return pageAtPercentageThrough(p.percent);\n  }\n\n\n  function pagesInComponent() {\n    return p.component.lastPageNumber();\n  }\n\n\n  function chapterInfo() {\n    if (p.chapter) {\n      return p.chapter;\n    }\n    return p.chapter = p.component.chapterForPage(pageNumber()+1);\n  }\n\n\n  function chapterTitle() {\n    var chp = chapterInfo();\n    return chp ? chp.title : null;\n  }\n\n\n  function chapterSrc() {\n    var src = componentId();\n    var cinfo = chapterInfo();\n    if (cinfo && cinfo.fragment) {\n      src += \"#\" + cinfo.fragment;\n    }\n    return src;\n  }\n\n\n  function getLocus(options) {\n    options = options || {};\n    var locus = {\n      page: pageNumber(),\n      componentId: componentId()\n    }\n    if (options.direction) {\n      locus.page += options.direction;\n    } else {\n      locus.percent = percentAtBottomOfPage();\n    }\n    return locus;\n  }\n\n\n  // Returns how far this place is in the entire book (0 - start, 1.0 - end).\n  //\n  function percentageOfBook() {\n    var book = p.component.properties.book;\n    var componentIds = book.properties.componentIds;\n    var weights = book.componentWeights();\n    var cmptIndex = p.component.properties.index;\n    var pc = weights[cmptIndex] * p.percent;\n    for (var i = 0, ii = cmptIndex; i < ii; ++i) { pc += weights[i]; }\n\n    // Note: This is a decent estimation of current page number and total\n    // number of pages, but it's very approximate. Could be improved by storing\n    // the page counts of all components accessed (since the dimensions of the\n    // reader last changed), and averaging the result across them. (You\n    // probably want to ignore calcs for components < 2 or 3 pages long, too.\n    // The bigger the component, the more accurate the calculation.)\n    //\n    // var bkPages = p.component.lastPageNumber() / weights[cmptIndex];\n    // console.log('Page: '+ Math.floor(pc*bkPages)+ ' of '+ Math.floor(bkPages));\n\n    return pc;\n  }\n\n\n  function onFirstPageOfBook() {\n    return p.component.properties.index == 0 && pageNumber() == 1;\n  }\n\n\n  function onLastPageOfBook() {\n    return (\n      p.component.properties.index ==\n        p.component.properties.book.properties.lastCIndex &&\n      pageNumber() == p.component.lastPageNumber()\n    );\n  }\n\n\n  API.setPlace = setPlace;\n  API.setPercentageThrough = setPercentageThrough;\n  API.componentId = componentId;\n  API.percentAtTopOfPage = percentAtTopOfPage;\n  API.percentOnPage = percentOnPage;\n  API.percentAtBottomOfPage = percentAtBottomOfPage;\n  API.pageAtPercentageThrough = pageAtPercentageThrough;\n  API.pageNumber = pageNumber;\n  API.pagesInComponent = pagesInComponent;\n  API.chapterInfo = chapterInfo;\n  API.chapterTitle = chapterTitle;\n  API.chapterSrc = chapterSrc;\n  API.getLocus = getLocus;\n  API.percentageOfBook = percentageOfBook;\n  API.onFirstPageOfBook = onFirstPageOfBook;\n  API.onLastPageOfBook = onLastPageOfBook;\n\n  API.percentageThrough = k.PAGE_ANCHOR == 'bottom' ? percentAtBottomOfPage :\n    k.PAGE_ANCHOR == 'offset' ? percentOnPage :\n    percentAtTopOfPage;\n\n  return API;\n}\n\n\n// Can set this to 'top', 'offset' or 'bottom'. Old Monocle behaviour is 'bottom'.\n//\nMonocle.Place.PAGE_ANCHOR = 'offset';\nMonocle.Place.PAGE_ANCHOR_OFFSET = 0.1;\n\n\nMonocle.Place.FromPageNumber = function (component, pageNumber) {\n  var place = new Monocle.Place();\n  place.setPlace(component, pageNumber);\n  return place;\n}\n\n\nMonocle.Place.FromPercentageThrough = function (component, percent) {\n  var place = new Monocle.Place();\n  place.setPercentageThrough(component, percent);\n  return place;\n}\n\n\n// We can't create a place from a percentage of the book, because the\n// component may not have been loaded yet. But we can get a locus.\n//\nMonocle.Place.percentOfBookToLocus = function (reader, percent) {\n  var book = reader.getBook();\n  var componentIds = book.properties.componentIds;\n  var weights = book.componentWeights();\n  var cmptIndex = 0, cmptWeight = 0;\n  percent = Math.min(percent, 0.99999);\n  while (percent >= 0) {\n    cmptWeight = weights[cmptIndex];\n    percent -= weights[cmptIndex];\n    if (percent >= 0) {\n      cmptIndex += 1;\n      if (cmptIndex >= weights.length) {\n        console.error('Unable to calculate locus from percentage: '+percent);\n        return;\n      }\n    }\n  }\n  var cmptPercent = (percent + cmptWeight) / cmptWeight;\n  return { componentId: componentIds[cmptIndex], percent: cmptPercent }\n}\n;\n/* COMPONENT */\n\n// See the properties declaration for details of constructor arguments.\n//\nMonocle.Component = function (book, id, index, chapters, source) {\n\n  var API = { constructor: Monocle.Component }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    // a back-reference to the public API of the book that owns this component\n    book: book,\n\n    // the string that represents this component in the book's component array\n    id: id,\n\n    // the position in the book's components array of this component\n    index: index,\n\n    // The chapters argument is an array of objects that list the chapters that\n    // can be found in this component. A chapter object is defined as:\n    //\n    //  {\n    //     title: str,\n    //     fragment: str, // optional anchor id\n    //     percent: n     // how far into the component the chapter begins\n    //  }\n    //\n    // NOTE: the percent property is calculated by the component - you only need\n    // to pass in the title and the optional id string.\n    //\n    chapters: chapters,\n\n    // the frame provided by dataSource.getComponent() for this component\n    source: source\n  }\n\n\n  // Makes this component the active component for the pageDiv. There are\n  // several strategies for this (see loadFrame).\n  //\n  // When the component has been loaded into the pageDiv's frame, the callback\n  // will be invoked with the pageDiv and this component as arguments.\n  //\n  function applyTo(pageDiv, callback) {\n    prepareSource(pageDiv.m.reader);\n\n    var evtData = { 'page': pageDiv, 'source': p.source };\n    pageDiv.m.reader.dispatchEvent('monocle:componentchanging', evtData);\n\n    var onLoaded = function () {\n      setupFrame(\n        pageDiv,\n        pageDiv.m.activeFrame,\n        function () { callback(pageDiv, API) }\n      );\n    }\n\n    Monocle.defer(function () { loadFrame(pageDiv, onLoaded); });\n  }\n\n\n  // Loads this component into the given frame, using one of the following\n  // strategies:\n  //\n  // * HTML - a HTML string\n  // * URL - a URL string\n  // * Nodes - an array of DOM body nodes (NB: no way to populate head)\n  // * Document - a DOM DocumentElement object\n  //\n  function loadFrame(pageDiv, callback) {\n    var frame = pageDiv.m.activeFrame;\n\n    // We own this frame now.\n    frame.m.component = API;\n\n    // Hide the frame while we're changing it.\n    frame.style.visibility = \"hidden\";\n\n    frame.whenDocumentReady = function () {\n      var doc = frame.contentDocument;\n      var evtData = { 'page': pageDiv, 'document': doc, 'component': API };\n      pageDiv.m.reader.dispatchEvent('monocle:componentmodify', evtData);\n      frame.whenDocumentReady = null;\n    }\n\n    if (p.source.html) {\n      return loadFrameFromHTML(p.source.html || p.source, frame, callback);\n    } else if (p.source.url) {\n      return loadFrameFromURL(p.source.url, frame, callback);\n    } else if (p.source.doc) {\n      return loadFrameFromDocument(p.source.doc, frame, callback);\n    }\n  }\n\n\n  // LOAD STRATEGY: HTML\n  // Loads a HTML string into the given frame, invokes the callback once loaded.\n  //\n  function loadFrameFromHTML(src, frame, callback) {\n    var fn = function () {\n      Monocle.Events.deafen(frame, 'load', fn);\n      frame.whenDocumentReady();\n      Monocle.defer(callback);\n    }\n    Monocle.Events.listen(frame, 'load', fn);\n    if (Monocle.Browser.env.loadHTMLWithDocWrite) {\n      frame.contentDocument.open('text/html', 'replace');\n      frame.contentDocument.write(src);\n      frame.contentDocument.close();\n    } else {\n      frame.contentWindow['monCmptData'] = src;\n      frame.src = \"javascript:window['monCmptData'];\"\n    }\n  }\n\n\n  // LOAD STRATEGY: URL\n  // Loads the URL into the given frame, invokes callback once loaded.\n  //\n  function loadFrameFromURL(url, frame, callback) {\n    // If it's a relative path, we need to make it absolute.\n    if (!url.match(/^\\//)) {\n      url = absoluteURL(url);\n    }\n    var onDocumentReady = function () {\n      Monocle.Events.deafen(frame, 'load', onDocumentReady);\n      frame.whenDocumentReady();\n    }\n    var onDocumentLoad = function () {\n      Monocle.Events.deafen(frame, 'load', onDocumentLoad);\n      Monocle.defer(callback);\n    }\n    Monocle.Events.listen(frame, 'load', onDocumentReady);\n    Monocle.Events.listen(frame, 'load', onDocumentLoad);\n    frame.contentWindow.location.replace(url);\n  }\n\n\n  // LOAD STRATEGY: DOCUMENT\n  // Replaces the DocumentElement of the given frame with the given srcDoc.\n  // Invokes the callback when loaded.\n  //\n  function loadFrameFromDocument(srcDoc, frame, callback) {\n    var doc = frame.contentDocument;\n\n    // WebKit has an interesting quirk. The <base> tag must exist in the\n    // document being replaced, not the new document.\n    if (Monocle.Browser.is.WebKit) {\n      var srcBase = srcDoc.querySelector('base');\n      if (srcBase) {\n        var head = doc.querySelector('head');\n        if (!head) {\n          try {\n            head = doc.createElement('head');\n            prependChild(doc.documentElement, head);\n          } catch (e) {\n            head = doc.body;\n          }\n        }\n        var base = doc.createElement('base');\n        base.setAttribute('href', srcBase.href);\n        head.appendChild(base);\n      }\n    }\n\n    doc.replaceChild(\n      doc.importNode(srcDoc.documentElement, true),\n      doc.documentElement\n    );\n\n    // NB: It's a significant problem with this load strategy that there's\n    // no indication when it is complete.\n    Monocle.defer(callback);\n  }\n\n\n  // Once a frame is loaded with this component, call this method to style\n  // and measure its contents.\n  //\n  function setupFrame(pageDiv, frame, callback) {\n    updateDimensions(pageDiv, function () {\n      frame.style.visibility = \"visible\";\n\n      // Find the place of any chapters in the component.\n      locateChapters(pageDiv);\n\n      // Nothing can prevent iframe scrolling on Android, so we have to undo it.\n      if (Monocle.Browser.on.Android) {\n        Monocle.Events.listen(frame.contentWindow, 'scroll', function () {\n          frame.contentWindow.scrollTo(0,0);\n        });\n      }\n\n      // Announce that the component has changed.\n      var doc = frame.contentDocument;\n      var evtData = { 'page': pageDiv, 'document': doc, 'component': API };\n      pageDiv.m.reader.dispatchEvent('monocle:componentchange', evtData);\n\n      callback();\n    });\n  }\n\n\n  // Checks whether the pageDiv dimensions have changed. If they have,\n  // remeasures dimensions and returns true. Otherwise returns false.\n  //\n  function updateDimensions(pageDiv, callback) {\n    pageDiv.m.dimensions.update(function (pageLength) {\n      p.pageLength = pageLength;\n      if (typeof callback == \"function\") { callback() };\n    });\n  }\n\n\n  // Iterates over all the chapters that are within this component\n  // (according to the array we were provided on initialization) and finds\n  // their location (in percentage terms) within the text.\n  //\n  // Stores this percentage with the chapter object in the chapters array.\n  //\n  function locateChapters(pageDiv) {\n    if (p.chapters[0] && typeof p.chapters[0].percent == \"number\") {\n      return;\n    }\n    var doc = pageDiv.m.activeFrame.contentDocument;\n    for (var i = 0; i < p.chapters.length; ++i) {\n      var chp = p.chapters[i];\n      chp.percent = 0;\n      if (chp.fragment) {\n        var node = doc.getElementById(chp.fragment);\n        chp.percent = pageDiv.m.dimensions.percentageThroughOfNode(node);\n      }\n    }\n    return p.chapters;\n  }\n\n\n  // For a given page number within the component, return the chapter that\n  // starts on or most-recently-before this page.\n  //\n  // Useful, for example, in displaying the current chapter title as a\n  // running head on the page.\n  //\n  function chapterForPage(pageN) {\n    var cand = null;\n    var percent = (pageN - 1) / p.pageLength;\n    for (var i = 0; i < p.chapters.length; ++i) {\n      if (percent >= p.chapters[i].percent) {\n        cand = p.chapters[i];\n      } else {\n        return cand;\n      }\n    }\n    return cand;\n  }\n\n\n  // For a given chapter fragment (the bit after the hash\n  // in eg, \"index.html#foo\"), return the page number on which\n  // the chapter starts. If the fragment is null or blank, will\n  // return the first page of the component.\n  //\n  function pageForChapter(fragment, pageDiv) {\n    if (!fragment) {\n      return 1;\n    }\n    for (var i = 0; i < p.chapters.length; ++i) {\n      if (p.chapters[i].fragment == fragment) {\n        return percentToPageNumber(p.chapters[i].percent);\n      }\n    }\n    var doc = pageDiv.m.activeFrame.contentDocument;\n    var node = doc.getElementById(fragment);\n    var percent = pageDiv.m.dimensions.percentageThroughOfNode(node);\n    return percentToPageNumber(percent);\n  }\n\n\n  function pageForXPath(xpath, pageDiv) {\n    var doc = pageDiv.m.activeFrame.contentDocument;\n    var percent = 0;\n    if (Monocle.Browser.env.supportsXPath) {\n      var node = doc.evaluate(xpath, doc, null, 9, null).singleNodeValue;\n      if (node) {\n        percent = pageDiv.m.dimensions.percentageThroughOfNode(node);\n      }\n    } else {\n      console.warn(\"XPath not supported in this client.\");\n    }\n    return percentToPageNumber(percent);\n  }\n\n\n  function pageForSelector(selector, pageDiv) {\n    var doc = pageDiv.m.activeFrame.contentDocument;\n    var percent = 0;\n    if (Monocle.Browser.env.supportsQuerySelector) {\n      var node = doc.querySelector(selector);\n      if (node) {\n        percent = pageDiv.m.dimensions.percentageThroughOfNode(node);\n      }\n    } else {\n      console.warn(\"querySelector not supported in this client.\");\n    }\n    return percentToPageNumber(percent);\n  }\n\n\n  function percentToPageNumber(pc) {\n    return Math.floor(pc * p.pageLength) + 1;\n  }\n\n\n  // A public getter for p.pageLength.\n  //\n  function lastPageNumber() {\n    return p.pageLength;\n  }\n\n\n  function prepareSource(reader) {\n    if (p.sourcePrepared) { return; }\n    p.sourcePrepared = true;\n\n    if (typeof p.source == \"string\") {\n      p.source = { html: p.source };\n    }\n\n    // If supplied as escaped javascript, unescape it to HTML by evalling it.\n    if (p.source.javascript) {\n      console.deprecation(\n        \"Loading a component by 'javascript' is deprecated. \" +\n        \"Use { 'html': src } -- no need to escape or clean the string.\"\n      );\n      var src = p.source.javascript;\n      src = src.replace(/\\\\n/g, \"\\n\");\n      src = src.replace(/\\\\r/g, \"\\r\");\n      src = src.replace(/\\\\'/g, \"'\");\n      p.source = { html: src };\n    }\n\n    // If supplied as DOM nodes, convert to HTML by concatenating outerHTMLs.\n    if (p.source.nodes) {\n      var srcs = [];\n      for (var i = 0, ii = p.source.nodes.length; i < ii; ++i) {\n        var node = p.source.nodes[i];\n        if (node.outerHTML) {\n          srcs.push(node.outerHTML);\n        } else {\n          var div = document.createElement('div');\n          div.appendChild(node.cloneNode(true));\n          srcs.push(div.innerHTML);\n          delete(div);\n        }\n      }\n      p.source = { html: srcs.join('') };\n    }\n\n    if (p.source.html && !p.source.html.match(new RegExp(\"<base\\s.+>\", \"im\"))) {\n      var baseURI = computeBaseURI(reader);\n      if (baseURI) {\n        p.source.html = p.source.html.replace(\n          new RegExp(\"(<head[^>]*>)\", \"im\"),\n          '$1<base href=\"'+baseURI+'\" />'\n        );\n      }\n    }\n\n    if (p.source.doc && !p.source.doc.querySelector('base')) {\n      var srcHead = p.source.doc.querySelector('head') || p.source.doc.body;\n      var baseURI = computeBaseURI(reader);\n      if (srcHead && baseURI) {\n        var srcBase = p.source.doc.createElement('base');\n        srcBase.setAttribute('href', baseURI);\n        prependChild(srcHead, srcBase);\n      }\n    }\n  }\n\n\n  function computeBaseURI(reader) {\n    var evtData = { cmptId: p.id, cmptURI: absoluteURL(p.id) }\n    if (reader.dispatchEvent('monocle:component:baseuri', evtData, true)) {\n      return evtData.cmptURI;\n    }\n  }\n\n\n  function absoluteURL(url) {\n    var link = document.createElement('a');\n    link.setAttribute('href', url);\n    result = link.href;\n    delete(link);\n    return result;\n  }\n\n\n  function prependChild(pr, el) {\n    pr.firstChild ? pr.insertBefore(el, pr.firstChild) : pr.appendChild(el);\n  }\n\n\n  API.applyTo = applyTo;\n  API.updateDimensions = updateDimensions;\n  API.chapterForPage = chapterForPage;\n  API.pageForChapter = pageForChapter;\n  API.pageForXPath = pageForXPath;\n  API.pageForSelector = pageForSelector;\n  API.lastPageNumber = lastPageNumber;\n\n  return API;\n}\n;\nMonocle.Selection = function (reader) {\n  var API = { constructor: Monocle.Selection };\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    reader: reader,\n    lastSelection: []\n  };\n\n\n  function initialize() {\n    if (k.SELECTION_POLLING_INTERVAL) {\n      setInterval(pollSelection, k.SELECTION_POLLING_INTERVAL);\n    }\n  }\n\n\n  function pollSelection() {\n    var index = 0, frame = null;\n    while (frame = reader.dom.find('component', index++)) {\n      if (frame.contentWindow) {\n        pollSelectionOnWindow(frame.contentWindow, index);\n      }\n    }\n  }\n\n\n  function pollSelectionOnWindow(win, index) {\n    var sel = win.getSelection();\n    var lm = p.lastSelection[index] || {};\n    var nm = p.lastSelection[index] = {\n      selected: anythingSelected(win),\n      range: sel.rangeCount ? sel.getRangeAt(0) : null,\n      string: sel.toString()\n    };\n    if (nm.selected) {\n      nm.rangeStartContainer = nm.range.startContainer;\n      nm.rangeEndContainer = nm.range.endContainer;\n      nm.rangeStartOffset = nm.range.startOffset;\n      nm.rangeEndOffset = nm.range.endOffset;\n      if (!sameRange(nm, lm)) {\n        p.reader.dispatchEvent('monocle:selection', nm);\n      }\n    } else if (lm.selected) {\n      p.reader.dispatchEvent('monocle:deselection', lm);\n    }\n  }\n\n\n  function sameRange(m1, m2) {\n    return (\n      m1.rangeStartContainer == m2.rangeStartContainer &&\n      m1.rangeEndContainer == m2.rangeEndContainer &&\n      m1.rangeStartOffset == m2.rangeStartOffset &&\n      m1.rangeEndOffset == m2.rangeEndOffset\n    );\n  }\n\n\n  // Given a window object, remove any user selections within. Trivial in\n  // most browsers, but involving major mojo on iOS.\n  //\n  function deselect() {\n    var index = 0, frame = null;\n    while (frame = reader.dom.find('component', index++)) {\n      deselectOnWindow(frame.contentWindow);\n    }\n  }\n\n\n  function deselectOnWindow(win) {\n    win = win || window;\n    if (!anythingSelected(win)) { return; }\n\n    if (Monocle.Browser.iOSVersion && !Monocle.Browser.iOSVersionBelow(5)) {\n      preservingScale(function () {\n        preservingScrollPosition(function () {\n          var inp = document.createElement('input');\n          inp.style.cssText = [\n            'position: absolute',\n            'top: 0',\n            'left: 0',\n            'width: 0',\n            'height: 0'\n          ].join(';');\n          document.body.appendChild(inp);\n          inp.focus();\n          document.body.removeChild(inp);\n        })\n      });\n    }\n\n    var sel = win.getSelection();\n    sel.removeAllRanges();\n    win.document.body.scrollLeft = 0;\n    win.document.body.scrollTop = 0;\n  }\n\n\n  function preservingScrollPosition(fn) {\n    var sx = window.scrollX, sy = window.scrollY;\n    fn();\n    window.scrollTo(sx, sy);\n  }\n\n\n  function preservingScale(fn) {\n    var head = document.querySelector('head');\n    var ovp = head.querySelector('meta[name=viewport]');\n    var createViewportMeta = function (content) {\n      var elem = document.createElement('meta');\n      elem.setAttribute('name', 'viewport');\n      elem.setAttribute('content', content);\n      head.appendChild(elem);\n      return elem;\n    }\n\n    if (ovp) {\n      var ovpcontent = ovp.getAttribute('content');\n      var re = /user-scalable\\s*=\\s*([^,$\\s])*/;\n      var result = ovpcontent.match(re);\n      if (result && ['no', '0'].indexOf(result[1]) >= 0) {\n        fn();\n      } else {\n        var nvpcontent = ovpcontent.replace(re, '');\n        nvpcontent += nvpcontent ? ', ' : '';\n        nvpcontent += 'user-scalable=no';\n        head.removeChild(ovp);\n        var nvp = createViewportMeta(nvpcontent);\n        fn();\n        head.removeChild(nvp);\n        head.appendChild(ovp);\n      }\n    } else {\n      var nvp = createViewportMeta('user-scalable=no');\n      fn();\n      nvp.setAttribute('content', 'user-scalable=yes');\n    }\n  }\n\n\n  function anythingSelected(win) {\n    return !win.getSelection().isCollapsed;\n  }\n\n\n  API.deselect = deselect;\n\n\n  initialize();\n\n  return API;\n}\n\n\nMonocle.Selection.SELECTION_POLLING_INTERVAL = 250;\nMonocle.Billboard = function (reader) {\n  var API = { constructor: Monocle.Billboard };\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    reader: reader,\n    cntr: null\n  };\n\n\n  function show(urlOrElement, options) {\n    p.reader.dispatchEvent('monocle:modal:on');\n    if (p.cntr) { return console.warn(\"Modal billboard already showing.\"); }\n\n    var options = options || {};\n    var elem = urlOrElement;\n    p.cntr = reader.dom.append('div', k.CLS.cntr);\n    if (typeof urlOrElement == 'string') {\n      var url = urlOrElement;\n      p.inner = elem = p.cntr.dom.append('iframe', k.CLS.inner);\n      elem.setAttribute('src', url);\n    } else {\n      p.inner = p.cntr.dom.append('div', k.CLS.inner);\n      p.inner.appendChild(elem);\n    }\n    p.dims = [\n      elem.naturalWidth || elem.offsetWidth,\n      elem.naturalHeight || elem.offsetHeight\n    ];\n    if (options.closeButton != false) {\n      var cBtn = p.cntr.dom.append('div', k.CLS.closeButton);\n      Monocle.Events.listenForTap(cBtn, hide);\n    }\n    align(options.align || 'left top');\n    p.reader.listen('monocle:resize', align);\n\n    shrink(options.from);\n    Monocle.defer(grow);\n  }\n\n\n  function hide(evt) {\n    shrink();\n    Monocle.Events.afterTransition(p.cntr, remove);\n  }\n\n\n  function grow() {\n    Monocle.Styles.transitionFor(p.cntr, 'transform', k.ANIM_MS, 'ease-in');\n    Monocle.Styles.affix(p.cntr, 'transform', 'translate(0, 0) scale(1)');\n  }\n\n\n  function shrink(from) {\n    p.from = from || p.from || [0,0];\n    var x = p.from[0]+'px';\n    var y = p.from[1]+'px';\n    Monocle.Styles.affix(\n      p.cntr,\n      'transform',\n      'translate('+x+','+y+') scale(0)'\n    );\n  }\n\n\n  function remove () {\n    p.cntr.parentNode.removeChild(p.cntr);\n    p.cntr = p.inner = null;\n    p.reader.deafen('monocle:resize', align);\n    p.reader.dispatchEvent('monocle:modal:off');\n  }\n\n\n  function align(loc) {\n    p.alignment = (typeof loc == 'string') ? loc : p.alignment;\n    if (!p.alignment) { return; }\n    if (p.dims[0] > p.inner.offsetWidth || p.dims[1] > p.inner.offsetHeight) {\n      p.cntr.dom.addClass(k.CLS.oversized);\n    } else {\n      p.cntr.dom.removeClass(k.CLS.oversized);\n    }\n\n    var s = p.alignment.split(/\\s+/);\n    var l = 0, t = 0;\n    var w = (p.inner.scrollWidth - p.inner.offsetWidth);\n    var h = (p.inner.scrollHeight - p.inner.offsetHeight);\n    if (s[0].match(/^\\d+$/)) {\n      l = Math.max(0, parseInt(s[0]) - (p.inner.offsetWidth / 2));\n    } else if (s[0] == 'center') {\n      l = w / 2;\n    } else if (s[0] == 'right') {\n      l = w;\n    }\n    if (s[1] && s[1].match(/^\\d+$/)) {\n      t = Math.max(0, parseInt(s[1]) - (p.inner.offsetHeight / 2));\n    } else if (!s[1] || s[1] == 'center') {\n      t =  h / 2;\n    } else if (s[1] == 'bottom') {\n      t = h;\n    }\n    p.inner.scrollLeft = l;\n    p.inner.scrollTop = t;\n  }\n\n\n  API.show = show;\n  API.hide = hide;\n  API.align= align;\n\n  return API;\n}\n\n\nMonocle.Billboard.CLS = {\n  cntr: 'billboard_container',\n  inner: 'billboard_inner',\n  closeButton: 'billboard_close',\n  oversized: 'billboard_oversized'\n}\n\nMonocle.Billboard.ANIM_MS = 400;\n// A panel is an invisible column of interactivity. When contact occurs\n// (mousedown, touchstart), the panel expands to the full width of its\n// container, to catch all interaction events and prevent them from hitting\n// other things.\n//\n// Panels are used primarily to provide hit zones for page flipping\n// interactions, but you can do whatever you like with them.\n//\n// After instantiating a panel and adding it to the reader as a control,\n// you can call listenTo() with a hash of methods for any of 'start', 'move'\n// 'end' and 'cancel'.\n//\nMonocle.Controls.Panel = function () {\n\n  var API = { constructor: Monocle.Controls.Panel }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    evtCallbacks: {}\n  }\n\n  function createControlElements(cntr) {\n    p.div = cntr.dom.make('div', k.CLS.panel);\n    p.div.dom.setStyles(k.DEFAULT_STYLES);\n    Monocle.Events.listenForContact(\n      p.div,\n      {\n        'start': start,\n        'move': move,\n        'end': end,\n        'cancel': cancel\n      },\n      { useCapture: false }\n    );\n    return p.div;\n  }\n\n\n  function setDirection(dir) {\n    p.direction = dir;\n  }\n\n\n  function listenTo(evtCallbacks) {\n    p.evtCallbacks = evtCallbacks;\n  }\n\n\n  function deafen() {\n    p.evtCallbacks = {}\n  }\n\n\n  function start(evt) {\n    p.contact = true;\n    evt.m.offsetX += p.div.offsetLeft;\n    evt.m.offsetY += p.div.offsetTop;\n    expand();\n    invoke('start', evt);\n  }\n\n\n  function move(evt) {\n    if (!p.contact) {\n      return;\n    }\n    invoke('move', evt);\n  }\n\n\n  function end(evt) {\n    if (!p.contact) {\n      return;\n    }\n    Monocle.Events.deafenForContact(p.div, p.listeners);\n    contract();\n    p.contact = false;\n    invoke('end', evt);\n  }\n\n\n  function cancel(evt) {\n    if (!p.contact) {\n      return;\n    }\n    Monocle.Events.deafenForContact(p.div, p.listeners);\n    contract();\n    p.contact = false;\n    invoke('cancel', evt);\n  }\n\n\n  function invoke(evtType, evt) {\n    if (p.evtCallbacks[evtType]) {\n      p.evtCallbacks[evtType](p.direction, evt.m.offsetX, evt.m.offsetY, API);\n    }\n    evt.preventDefault();\n  }\n\n\n  function expand() {\n    if (p.expanded) {\n      return;\n    }\n    p.div.dom.addClass(k.CLS.expanded);\n    p.expanded = true;\n  }\n\n\n  function contract(evt) {\n    if (!p.expanded) {\n      return;\n    }\n    p.div.dom.removeClass(k.CLS.expanded);\n    p.expanded = false;\n  }\n\n\n  API.createControlElements = createControlElements;\n  API.listenTo = listenTo;\n  API.deafen = deafen;\n  API.expand = expand;\n  API.contract = contract;\n  API.setDirection = setDirection;\n\n  return API;\n}\n\n\nMonocle.Controls.Panel.CLS = {\n  panel: 'panel',\n  expanded: 'controls_panel_expanded'\n}\nMonocle.Controls.Panel.DEFAULT_STYLES = {\n  position: 'absolute',\n  height: '100%'\n}\n;\n// The simplest page-flipping interaction system: contact to the left half of\n// the reader turns back one page, contact to the right half turns forward\n// one page.\n//\nMonocle.Panels.TwoPane = function (flipper, evtCallbacks) {\n\n  var API = { constructor: Monocle.Panels.TwoPane }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {}\n\n\n  function initialize() {\n    p.panels = {\n      forwards: new Monocle.Controls.Panel(),\n      backwards: new Monocle.Controls.Panel()\n    }\n\n    for (dir in p.panels) {\n      flipper.properties.reader.addControl(p.panels[dir]);\n      p.panels[dir].listenTo(evtCallbacks);\n      p.panels[dir].setDirection(flipper.constants[dir.toUpperCase()]);\n      var style = { \"width\": k.WIDTH };\n      style[(dir == \"forwards\" ? \"right\" : \"left\")] = 0;\n      p.panels[dir].properties.div.dom.setStyles(style);\n    }\n  }\n\n\n  initialize();\n\n  return API;\n}\n\nMonocle.Panels.TwoPane.WIDTH = \"50%\";\n// A three-pane system of page interaction. The left 33% turns backwards, the\n// right 33% turns forwards, and contact on the middle third causes the\n// system to go into \"interactive mode\". In this mode, the page-flipping panels\n// are only active in the margins, and all of the actual text content of the\n// book is selectable. The user can exit \"interactive mode\" by hitting the little\n// IMode icon in the lower right corner of the reader.\n//\nMonocle.Panels.IMode = function (flipper, evtCallbacks) {\n\n  var API = { constructor: Monocle.Panels.IMode }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {}\n\n\n  function initialize() {\n    p.flipper = flipper;\n    p.reader = flipper.properties.reader;\n    p.panels = {\n      forwards: new Monocle.Controls.Panel(),\n      backwards: new Monocle.Controls.Panel()\n    }\n    p.divs = {}\n\n    for (dir in p.panels) {\n      p.reader.addControl(p.panels[dir]);\n      p.divs[dir] = p.panels[dir].properties.div;\n      p.panels[dir].listenTo(evtCallbacks);\n      p.panels[dir].setDirection(flipper.constants[dir.toUpperCase()]);\n      p.divs[dir].style.width = \"33%\";\n      p.divs[dir].style[dir == \"forwards\" ? \"right\" : \"left\"] = 0;\n    }\n\n    p.panels.central = new Monocle.Controls.Panel();\n    p.reader.addControl(p.panels.central);\n    p.divs.central = p.panels.central.properties.div;\n    p.divs.central.dom.setStyles({ left: \"33%\", width: \"34%\" });\n    menuCallbacks({ end: modeOn });\n\n    for (dir in p.panels) {\n      p.divs[dir].dom.addClass('panels_imode_panel');\n      p.divs[dir].dom.addClass('panels_imode_'+dir+'Panel');\n    }\n\n    p.toggleIcon = {\n      createControlElements: function (cntr) {\n        var div = cntr.dom.make('div', 'panels_imode_toggleIcon');\n        Monocle.Events.listenForTap(div, modeOff);\n        return div;\n      }\n    }\n    p.reader.addControl(p.toggleIcon, null, { hidden: true });\n  }\n\n\n  function menuCallbacks(callbacks) {\n    p.menuCallbacks = callbacks;\n    p.panels.central.listenTo(p.menuCallbacks);\n  }\n\n\n  function toggle() {\n    p.interactive ? modeOff() : modeOn();\n  }\n\n\n  function modeOn() {\n    if (p.interactive) {\n      return;\n    }\n\n    p.panels.central.contract();\n\n    var page = p.reader.visiblePages()[0];\n    var sheaf = page.m.sheafDiv;\n    var bw = sheaf.offsetLeft;\n    var fw = page.offsetWidth - (sheaf.offsetLeft + sheaf.offsetWidth);\n    bw = Math.floor(((bw - 2) / page.offsetWidth) * 10000 / 100 ) + \"%\";\n    fw = Math.floor(((fw - 2) / page.offsetWidth) * 10000 / 100 ) + \"%\";\n\n    startCameo(function () {\n      p.divs.forwards.style.width = fw;\n      p.divs.backwards.style.width = bw;\n      Monocle.Styles.affix(p.divs.central, 'transform', 'translateY(-100%)');\n    });\n\n    p.reader.showControl(p.toggleIcon);\n\n    p.interactive = true;\n    if (flipper.interactiveMode) {\n      flipper.interactiveMode(true);\n    }\n  }\n\n\n  function modeOff() {\n    if (!p.interactive) {\n      return;\n    }\n\n    p.panels.central.contract();\n\n    p.reader.selection.deselect();\n\n    startCameo(function () {\n      p.divs.forwards.style.width = \"33%\";\n      p.divs.backwards.style.width = \"33%\";\n      Monocle.Styles.affix(p.divs.central, 'transform', 'translateY(0)');\n    });\n\n    p.reader.hideControl(p.toggleIcon);\n\n    p.interactive = false;\n    if (flipper.interactiveMode) {\n      flipper.interactiveMode(false);\n    }\n  }\n\n\n  function startCameo(fn) {\n    // Set transitions on the panels.\n    var trn = Monocle.Panels.IMode.CAMEO_DURATION+\"ms ease-in\";\n    Monocle.Styles.affix(p.divs.forwards, 'transition', \"width \"+trn);\n    Monocle.Styles.affix(p.divs.backwards, 'transition', \"width \"+trn);\n    Monocle.Styles.affix(p.divs.central, 'transition', \"-webkit-transform \"+trn);\n\n    // Temporarily disable listeners.\n    for (var pan in p.panels) {\n      p.panels[pan].deafen();\n    }\n\n    // Set the panels to opaque.\n    for (var div in p.divs) {\n      p.divs[div].style.opacity = 1;\n    }\n\n    if (typeof WebkitTransitionEvent != \"undefined\") {\n      p.cameoListener = Monocle.Events.listen(\n        p.divs.central,\n        'webkitTransitionEnd',\n        endCameo\n      );\n    } else {\n      setTimeout(endCameo, k.CAMEO_DURATION);\n    }\n    fn();\n  }\n\n\n  function endCameo() {\n    setTimeout(function () {\n      // Remove panel transitions.\n      var trn = \"opacity linear \" + Monocle.Panels.IMode.LINGER_DURATION + \"ms\";\n      Monocle.Styles.affix(p.divs.forwards, 'transition', trn);\n      Monocle.Styles.affix(p.divs.backwards, 'transition', trn);\n      Monocle.Styles.affix(p.divs.central, 'transition', trn);\n\n      // Set the panels to transparent.\n      for (var div in p.divs) {\n        p.divs[div].style.opacity = 0;\n      }\n\n      // Re-enable listeners.\n      p.panels.forwards.listenTo(evtCallbacks);\n      p.panels.backwards.listenTo(evtCallbacks);\n      p.panels.central.listenTo(p.menuCallbacks);\n    }, Monocle.Panels.IMode.LINGER_DURATION);\n\n\n    if (p.cameoListener) {\n      Monocle.Events.deafen(p.divs.central, 'webkitTransitionEnd', endCameo);\n    }\n  }\n\n\n  API.toggle = toggle;\n  API.modeOn = modeOn;\n  API.modeOff = modeOff;\n  API.menuCallbacks = menuCallbacks;\n\n  initialize();\n\n  return API;\n}\n\nMonocle.Panels.IMode.CAMEO_DURATION = 250;\nMonocle.Panels.IMode.LINGER_DURATION = 250;\nMonocle.Panels.eInk = function (flipper, evtCallbacks) {\n\n  var API = { constructor: Monocle.Panels.eInk }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    flipper: flipper\n  }\n\n\n  function initialize() {\n    p.panel = new Monocle.Controls.Panel();\n    p.reader = p.flipper.properties.reader;\n    p.reader.addControl(p.panel);\n\n    p.panel.listenTo({ end: function (panel, x) {\n      if (x < p.panel.properties.div.offsetWidth / 2) {\n        p.panel.setDirection(flipper.constants.BACKWARDS);\n      } else {\n        p.panel.setDirection(flipper.constants.FORWARDS);\n      }\n      evtCallbacks.end(panel, x);\n    } });\n\n    var s = p.panel.properties.div.style;\n    p.reader.listen(\"monocle:componentchanging\", function () {\n      s.opacity = 1;\n      Monocle.defer(function () { s.opacity = 0 }, 40);\n    });\n    s.width = \"100%\";\n    s.background = \"#000\";\n    s.opacity = 0;\n\n    if (k.LISTEN_FOR_KEYS) {\n      Monocle.Events.listen(window.top.document, 'keyup', handleKeyEvent);\n    }\n  }\n\n\n  function handleKeyEvent(evt) {\n    var eventCharCode = evt.charCode || evt.keyCode;\n    var dir = null;\n    if (eventCharCode == k.KEYS[\"PAGEUP\"]) {\n      dir = flipper.constants.BACKWARDS;\n    } else if (eventCharCode == k.KEYS[\"PAGEDOWN\"]) {\n      dir = flipper.constants.FORWARDS;\n    }\n    if (dir) {\n      flipper.moveTo({ direction: dir });\n      evt.preventDefault();\n    }\n  }\n\n\n  initialize();\n\n  return API;\n}\n\n\nMonocle.Panels.eInk.LISTEN_FOR_KEYS = true;\nMonocle.Panels.eInk.KEYS = { \"PAGEUP\": 33, \"PAGEDOWN\": 34 };\n// Provides page-flipping panels only in the margins of the book. This is not\n// entirely suited to small screens with razor-thin margins, but is an\n// appropriate panel class for larger screens (like, say, an iPad).\n//\n// Since the flipper hit zones are only in the margins, the actual text content\n// of the book is always selectable.\n//\nMonocle.Panels.Marginal = function (flipper, evtCallbacks) {\n\n  var API = { constructor: Monocle.Panels.Marginal }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {}\n\n\n  function initialize() {\n    p.panels = {\n      forwards: new Monocle.Controls.Panel(),\n      backwards: new Monocle.Controls.Panel()\n    }\n\n    for (dir in p.panels) {\n      flipper.properties.reader.addControl(p.panels[dir]);\n      p.panels[dir].listenTo(evtCallbacks);\n      p.panels[dir].setDirection(flipper.constants[dir.toUpperCase()]);\n      with (p.panels[dir].properties.div.style) {\n        dir == \"forwards\" ? right = 0 : left = 0;\n      }\n    }\n    setWidths();\n\n    if (flipper.interactiveMode) {\n      flipper.interactiveMode(true);\n    }\n  }\n\n\n  function setWidths() {\n    var page = flipper.properties.reader.dom.find('page');\n    var sheaf = page.m.sheafDiv;\n    var bw = sheaf.offsetLeft;\n    var fw = page.offsetWidth - (sheaf.offsetLeft + sheaf.offsetWidth);\n    bw = Math.floor(((bw - 2) / page.offsetWidth) * 10000 / 100) + \"%\";\n    fw = Math.floor(((fw - 2) / page.offsetWidth) * 10000 / 100) + \"%\";\n    p.panels.forwards.properties.div.style.width = fw;\n    p.panels.backwards.properties.div.style.width = bw;\n  }\n\n\n  API.setWidths = setWidths;\n\n  initialize();\n\n  return API;\n}\n;\nMonocle.Panels.Magic = function (flipper, evtCallbacks) {\n\n  var API = { constructor: Monocle.Panels.Magic }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    flipper: flipper,\n    evtCallbacks: evtCallbacks,\n    parts: {},\n    action: {},\n    contacts: [],\n    startListeners: [],\n    disabled: false\n  }\n\n\n  function initialize() {\n    p.reader = flipper.properties.reader;\n    p.parts = {\n      reader: p.reader.dom.find('box'),\n      cmpts: []\n    }\n    for (var i = 0; i < p.flipper.pageCount; ++i) {\n      p.parts.cmpts.push(p.reader.dom.find('component', i));\n    }\n    initListeners();\n\n    p.reader.listen('monocle:componentmodify', initListeners);\n    p.reader.listen('monocle:magic:init', initListeners);\n    p.reader.listen('monocle:magic:halt', haltListeners);\n    p.reader.listen('monocle:modal:on', disable);\n    p.reader.listen('monocle:modal:off', enable);\n    Monocle.Events.listen(window, 'monocle:contact:cancel', resetAction);\n  }\n\n\n  function initListeners(evt) {\n    //console.log('magic:init');\n    stopListening();\n    startListening();\n  }\n\n\n  function haltListeners(evt) {\n    //console.log('magic:halt');\n    stopListening();\n  }\n\n\n  function disable(evt) {\n    //console.log('modal:on - halting magic');\n    stopListening();\n    p.disabled = true;\n  }\n\n\n  function enable(evt) {\n    //console.log('modal:off - initing magic');\n    p.disabled = false;\n    startListening();\n  }\n\n\n  function startListening() {\n    if (p.disabled || p.startListeners.length) { return; }\n\n    p.startListeners.push([\n      p.parts.reader,\n      Monocle.Events.listenForContact(\n        p.parts.reader,\n        { 'start': translatorFunction(p.parts.reader, readerContactStart) }\n      )\n    ]);\n\n    for (var i = 0, ii = p.parts.cmpts.length; i < ii; ++i) {\n      p.startListeners.push([\n        p.parts.cmpts[i].contentDocument.defaultView,\n        Monocle.Events.listenForContact(\n          p.parts.cmpts[i].contentDocument.defaultView,\n          { 'start': translatorFunction(p.parts.cmpts[i], cmptContactStart) }\n        )\n      ]);\n    }\n  }\n\n\n  function stopListening() {\n    if (p.disabled || !p.startListeners.length) { return; }\n    for (var j = 0, jj = p.startListeners.length; j < jj; ++j) {\n      Monocle.Events.deafenForContact(\n        p.startListeners[j][0],\n        p.startListeners[j][1]\n      );\n    }\n    p.startListeners = [];\n  }\n\n\n  function listenForMoveAndEnd(fnMove, fnEnd) {\n    listenOnElem(\n      document.defaultView,\n      translatorFunction(document.documentElement, fnMove),\n      translatorFunction(document.documentElement, fnEnd)\n    );\n    for (var i = 0, ii = p.parts.cmpts.length; i < ii; ++i) {\n      listenOnElem(\n        p.parts.cmpts[i].contentDocument.defaultView,\n        translatorFunction(p.parts.cmpts[i], fnMove),\n        translatorFunction(p.parts.cmpts[i], fnEnd)\n      );\n    }\n  }\n\n\n  function listenOnElem(elem, fnMove, fnEnd) {\n    var contactListeners = Monocle.Events.listenForContact(\n      elem,\n      {\n        'move': fnMove,\n        'end': function (evt) { deafenContactListeners(); fnEnd(evt); }\n      }\n    );\n    p.contacts.push([elem, contactListeners]);\n  }\n\n\n  function deafenContactListeners() {\n    for (var i = 0, ii = p.contacts.length; i < ii; ++i) {\n      Monocle.Events.deafenForContact(p.contacts[i][0], p.contacts[i][1]);\n    }\n    p.contacts = [];\n  }\n\n\n  function readerContactStart(evt) {\n    listenForMoveAndEnd(readerContactMove, readerContactEnd);\n    p.action.startX = evt.m.readerX;\n    p.action.startY = evt.m.readerY;\n    p.action.screenX = evt.m.screenX;\n    p.action.screenY = evt.m.screenY;\n    p.action.dir = evt.m.readerX > halfway() ? k.FORWARDS : k.BACKWARDS;\n    p.action.handled = !dispatch('monocle:magic:contact:start', evt);\n    if (!p.action.handled) { invoke('start', evt); }\n  }\n\n\n  function readerContactMove(evt) {\n    if (p.action.handled) {\n      dispatch('monocle:magic:contact:move', evt);\n    } else {\n      invoke('move', evt);\n    }\n    // Can't prevent mousemove, so has no effect there. Preventing default\n    // for touchmove will override scrolling, while still allowing selection.\n    evt.preventDefault();\n  }\n\n\n  function readerContactEnd(evt) {\n    p.action.endX = evt.m.readerX;\n    p.action.endY = evt.m.readerY;\n    if (dispatch('monocle:magic:contact', evt)) { invoke('end', evt); }\n    p.action = {};\n  }\n\n\n  function cmptContactStart(evt) {\n    if (actionIsCancelled(evt)) { return resetAction(); }\n    p.action.startX = evt.m.readerX;\n    p.action.startY = evt.m.readerY;\n    p.action.screenX = evt.m.screenX;\n    p.action.screenY = evt.m.screenY;\n    listenForMoveAndEnd(cmptContactMove, cmptContactEnd);\n  }\n\n\n  function cmptContactMove(evt) {\n    if (actionIsEmpty()) { return; }\n    if (actionIsCancelled(evt)) { return resetAction(); }\n\n    // Can't prevent mousemove, so has no effect there. Preventing default\n    // for touchmove will override scrolling, while still allowing selection.\n    evt.preventDefault();\n  }\n\n\n  function cmptContactEnd(evt) {\n    if (actionIsEmpty()) { return; }\n    if (actionIsCancelled(evt)) { return resetAction(); }\n    p.action.endX = evt.m.readerX;\n    p.action.endY = evt.m.readerY;\n    if (Math.abs(p.action.endX - p.action.startX) < k.LEEWAY) {\n      p.action.dir = p.action.startX > halfway() ? k.FORWARDS : k.BACKWARDS;\n    } else {\n      p.action.dir = p.action.startX > p.action.endX ? k.FORWARDS : k.BACKWARDS;\n    }\n\n    if (dispatch('monocle:magic:contact', evt)) {\n      invoke('start', evt);\n      invoke('end', evt);\n    }\n    p.action = {};\n  }\n\n\n  // Adds two new properties to evt.m:\n  // - readerX\n  // - readerY\n  //\n  // Calculated as the offset of the click from the top left of reader element.\n  //\n  // Then calls the passed function.\n  //\n  function translatorFunction(registrant, callback) {\n    return function (evt) {\n      translatingReaderOffset(registrant, evt, callback);\n    }\n  }\n\n\n  function translatingReaderOffset(registrant, evt, callback) {\n    if (typeof p.action.screenX != 'undefined') {\n      evt.m.readerX = p.action.startX + (evt.m.screenX - p.action.screenX);\n      evt.m.readerY = p.action.startY + (evt.m.screenY - p.action.screenY);\n    } else {\n      var dr = document.documentElement.getBoundingClientRect();\n      var rr = p.parts.reader.getBoundingClientRect();\n      rr = { left: rr.left - dr.left, top: rr.top - dr.top }\n\n      if (evt.view == window) {\n        evt.m.readerX = Math.round(evt.m.pageX - rr.left);\n        evt.m.readerY = Math.round(evt.m.pageY - rr.top);\n      } else {\n        var er = registrant.getBoundingClientRect();\n        er = { left: er.left - dr.left, top: er.top - dr.top }\n        evt.m.readerX = Math.round((er.left - rr.left) + evt.m.clientX);\n        evt.m.readerY = Math.round((er.top - rr.top) + evt.m.clientY);\n      }\n    }\n\n    callback(evt);\n  }\n\n\n  function halfway() {\n    return p.parts.reader.offsetWidth / 2;\n  }\n\n\n  function resetAction() {\n    p.action = {};\n    deafenContactListeners();\n  }\n\n\n  function actionIsCancelled(evt) {\n    var win = evt.target.ownerDocument.defaultView;\n    return (evt.defaultPrevented || !win.getSelection().isCollapsed);\n  }\n\n\n  function actionIsEmpty() {\n    return typeof p.action.startX == 'undefined';\n  }\n\n\n  // Returns true if the event WAS NOT cancelled.\n  function dispatch(evtName, trigger) {\n    var rr = p.parts.reader.getBoundingClientRect();\n    var evtData = {\n      trigger: trigger,\n      start: { x: p.action.startX, y: p.action.startY },\n      end: { x: p.action.endX, y: p.action.endY },\n      max: { x: rr.right - rr.left, y: rr.bottom - rr.top }\n    }\n    return p.reader.dispatchEvent(evtName, evtData, true);\n  }\n\n\n  function invoke(evtType, evt) {\n    if (p.evtCallbacks[evtType]) {\n      p.evtCallbacks[evtType](p.action.dir, evt.m.readerX, evt.m.readerY, API);\n    }\n  }\n\n\n  API.enable = enable;\n  API.disable = disable;\n\n  initialize();\n\n  return API;\n}\n\n\nMonocle.Panels.Magic.LEEWAY = 3;\nMonocle.Panels.Magic.FORWARDS = 1;\nMonocle.Panels.Magic.BACKWARDS = -1;\nMonocle.Dimensions.Columns = function (pageDiv) {\n\n  var API = { constructor: Monocle.Dimensions.Columns }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    page: pageDiv,\n    reader: pageDiv.m.reader,\n    length: 0,\n    width: 0\n  }\n\n  // Logically, forceColumn browsers can't have a gap, because that would\n  // make the minWidth > 200%. But how much greater? Not worth the effort.\n  k.GAP = Monocle.Browser.env.forceColumns ? 0 : 20;\n\n  function update(callback) {\n    setColumnWidth();\n    Monocle.defer(function () {\n      p.length = columnCount();\n      if (Monocle.DEBUG) {\n        console.log(\n          'page['+p.page.m.pageIndex+'] -> '+p.length+\n          ' ('+p.page.m.activeFrame.m.component.properties.id+')'\n        );\n      }\n      callback(p.length);\n    });\n  }\n\n\n  function setColumnWidth() {\n    var pdims = pageDimensions();\n    var ce = columnedElement();\n\n    p.width = pdims.width;\n\n    var rules = Monocle.Styles.rulesToString(k.STYLE[\"columned\"]);\n    rules += Monocle.Browser.css.toCSSDeclaration('column-width', pdims.col+'px');\n    rules += Monocle.Browser.css.toCSSDeclaration('column-gap', k.GAP+'px');\n    rules += Monocle.Browser.css.toCSSDeclaration('column-fill', 'auto');\n    rules += Monocle.Browser.css.toCSSDeclaration('transform', 'translateX(0)');\n\n    if (Monocle.Browser.env.forceColumns && ce.scrollHeight > pdims.height) {\n      rules += Monocle.Styles.rulesToString(k.STYLE['column-force']);\n      if (Monocle.DEBUG) {\n        console.warn(\"Force columns (\"+ce.scrollHeight+\" > \"+pdims.height+\")\");\n      }\n    }\n\n    if (ce.style.cssText != rules) {\n      // Update offset because we're translating to zero.\n      p.page.m.offset = 0;\n\n      // IE10 hack.\n      if (Monocle.Browser.env.documentElementHasScrollbars) {\n        ce.ownerDocument.documentElement.style.overflow = 'hidden';\n      }\n\n      // Apply body style changes.\n      ce.style.cssText = rules;\n\n      if (Monocle.Browser.env.scrollToApplyStyle) {\n        ce.scrollLeft = 0;\n      }\n    }\n  }\n\n\n  // Returns the element to which columns CSS should be applied.\n  //\n  function columnedElement() {\n    return p.page.m.activeFrame.contentDocument.body;\n  }\n\n\n  // Returns the width of the offsettable area of the columned element. By\n  // definition, the number of pages is always this divided by the\n  // width of a single page (eg, the client area of the columned element).\n  //\n  function columnedWidth() {\n    var bd = columnedElement();\n    var de = p.page.m.activeFrame.contentDocument.documentElement;\n\n    var w = Math.max(bd.scrollWidth, de.scrollWidth);\n\n    // Add one because the final column doesn't have right gutter.\n    // w += k.GAP;\n\n    if (!Monocle.Browser.env.widthsIgnoreTranslate && p.page.m.offset) {\n      w += p.page.m.offset;\n    }\n    return w;\n  }\n\n\n  function pageDimensions() {\n    var elem = p.page.m.sheafDiv;\n    var w = elem.clientWidth;\n    if (elem.getBoundingClientRect) { w = elem.getBoundingClientRect().width; }\n    if (Monocle.Browser.env.roundPageDimensions) { w = Math.round(w); }\n    return { col: w, width: w + k.GAP, height: elem.clientHeight }\n  }\n\n\n  function columnCount() {\n    return Math.ceil(columnedWidth() / pageDimensions().width)\n  }\n\n\n  function locusToOffset(locus) {\n    return pageDimensions().width * (locus.page - 1);\n  }\n\n\n  // Moves the columned element to the offset implied by the locus.\n  //\n  // The 'transition' argument is optional, allowing the translation to be\n  // animated. If not given, no change is made to the columned element's\n  // transition property.\n  //\n  function translateToLocus(locus, transition) {\n    var offset = locusToOffset(locus);\n    p.page.m.offset = offset;\n    translateToOffset(offset, transition);\n    return offset;\n  }\n\n\n  function translateToOffset(offset, transition) {\n    var ce = columnedElement();\n    if (transition) {\n      Monocle.Styles.affix(ce, \"transition\", transition);\n    }\n    Monocle.Styles.affix(ce, \"transform\", \"translateX(-\"+offset+\"px)\");\n  }\n\n\n  function percentageThroughOfNode(target) {\n    if (!target) { return 0; }\n    var doc = p.page.m.activeFrame.contentDocument;\n    var offset = 0;\n    if (Monocle.Browser.env.findNodesByScrolling) {\n      // First, remove translation...\n      translateToOffset(0);\n\n      // Store scroll offsets for all windows.\n      var win = s = p.page.m.activeFrame.contentWindow;\n      var scrollers = [\n        [win, win.scrollX, win.scrollY],\n        [window, window.scrollX, window.scrollY]\n      ];\n      //while (s != s.parent) { scrollers.push([s, s.scrollX]); s = s.parent; }\n\n      if (Monocle.Browser.env.sheafIsScroller) {\n        var scroller = p.page.m.sheafDiv;\n        var x = scroller.scrollLeft;\n        target.scrollIntoView();\n        offset = scroller.scrollLeft;\n      } else {\n        var scroller = win;\n        var x = scroller.scrollX;\n        target.scrollIntoView();\n        offset = scroller.scrollX;\n      }\n\n      // Restore scroll offsets for all windows.\n      while (s = scrollers.shift()) {\n        s[0].scrollTo(s[1], s[2]);\n      }\n\n      // ... finally, replace translation.\n      translateToOffset(p.page.m.offset);\n    } else {\n      offset = target.getBoundingClientRect().left;\n      offset -= doc.body.getBoundingClientRect().left;\n    }\n\n    // We know at least 1px will be visible, and offset should not be 0.\n    offset += 1;\n\n    // Percent is the offset divided by the total width of the component.\n    var percent = offset / (p.length * p.width);\n\n    // Page number would be offset divided by the width of a single page.\n    // var pageNum = Math.ceil(offset / pageDimensions().width);\n\n    return percent;\n  }\n\n\n  API.update = update;\n  API.percentageThroughOfNode = percentageThroughOfNode;\n\n  API.locusToOffset = locusToOffset;\n  API.translateToLocus = translateToLocus;\n\n  return API;\n}\n\n\nMonocle.Dimensions.Columns.STYLE = {\n  // Most of these are already applied to body, but they're repeated here\n  // in case columnedElement() is ever anything other than body.\n  \"columned\": {\n    \"margin\": \"0\",\n    \"padding\": \"0\",\n    \"height\": \"100%\",\n    \"width\": \"100%\",\n    \"position\": \"absolute\"\n  },\n  \"column-force\": {\n    \"min-width\": \"200%\",\n    \"overflow\": \"hidden\"\n  }\n}\n;\nMonocle.Flippers.Slider = function (reader) {\n\n  var API = { constructor: Monocle.Flippers.Slider }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    reader: reader,\n    pageCount: 2,\n    activeIndex: 1,\n    turnData: {}\n  }\n\n\n  function initialize() {\n    p.reader.listen(\"monocle:componentchanging\", showWaitControl);\n  }\n\n\n  function addPage(pageDiv) {\n    pageDiv.m.dimensions = new Monocle.Dimensions.Columns(pageDiv);\n\n    // BROWSERHACK: Firefox 4 is prone to beachballing on the first page turn\n    // unless a zeroed translateX has been applied to the page div.\n    Monocle.Styles.setX(pageDiv, 0);\n  }\n\n\n  function visiblePages() {\n    return [upperPage()];\n  }\n\n\n  function listenForInteraction(panelClass) {\n    // BROWSERHACK: Firstly, prime interactiveMode for buggy iOS WebKit.\n    interactiveMode(true);\n    interactiveMode(false);\n\n    if (typeof panelClass != \"function\") {\n      panelClass = k.DEFAULT_PANELS_CLASS;\n      if (!panelClass) {\n        console.warn(\"Invalid panel class.\")\n      }\n    }\n    p.panels = new panelClass(\n      API,\n      {\n        'start': lift,\n        'move': turning,\n        'end': release,\n        'cancel': release\n      }\n    );\n  }\n\n\n  // A panel can call this with true/false to indicate that the user needs\n  // to be able to select or otherwise interact with text.\n  function interactiveMode(bState) {\n    p.reader.dispatchEvent('monocle:interactive:'+(bState ? 'on' : 'off'));\n  }\n\n\n  function getPlace(pageDiv) {\n    pageDiv = pageDiv || upperPage();\n    return pageDiv.m ? pageDiv.m.place : null;\n  }\n\n\n  function moveTo(locus, callback) {\n    var fn = function () {\n      prepareNextPage(function () {\n        if (typeof callback == \"function\") { callback(); }\n        announceTurn();\n      });\n    }\n    setPage(upperPage(), locus, fn);\n  }\n\n\n  function setPage(pageDiv, locus, callback) {\n    p.reader.getBook().setOrLoadPageAt(\n      pageDiv,\n      locus,\n      function (locus) {\n        pageDiv.m.dimensions.translateToLocus(locus);\n        Monocle.defer(callback);\n      }\n    );\n  }\n\n\n  function upperPage() {\n    return p.reader.dom.find('page', p.activeIndex);\n  }\n\n\n  function lowerPage() {\n    return p.reader.dom.find('page', (p.activeIndex + 1) % 2);\n  }\n\n\n  function flipPages() {\n    upperPage().style.zIndex = 1;\n    lowerPage().style.zIndex = 2;\n    return p.activeIndex = (p.activeIndex + 1) % 2;\n  }\n\n\n  function lift(dir, boxPointX) {\n    if (p.turnData.lifting || p.turnData.releasing) { return; }\n\n    p.reader.selection.deselect();\n\n    p.turnData.points = {\n      start: boxPointX,\n      min: boxPointX,\n      max: boxPointX\n    }\n    p.turnData.lifting = true;\n\n    var place = getPlace();\n\n    if (dir == k.FORWARDS) {\n      if (place.onLastPageOfBook()) {\n        p.reader.dispatchEvent(\n          'monocle:boundaryend',\n          {\n            locus: getPlace().getLocus({ direction : dir }),\n            page: upperPage()\n          }\n        );\n        resetTurnData();\n        return;\n      }\n      onGoingForward(boxPointX);\n    } else if (dir == k.BACKWARDS) {\n      if (place.onFirstPageOfBook()) {\n        p.reader.dispatchEvent(\n          'monocle:boundarystart',\n          {\n            locus: getPlace().getLocus({ direction : dir }),\n            page: upperPage()\n          }\n        );\n        resetTurnData();\n        return;\n      }\n      onGoingBackward(boxPointX);\n    } else {\n      console.warn(\"Invalid direction: \" + dir);\n    }\n  }\n\n\n  function turning(dir, boxPointX) {\n    if (!p.turnData.points) { return; }\n    if (p.turnData.lifting || p.turnData.releasing) { return; }\n    checkPoint(boxPointX);\n    slideToCursor(boxPointX, null, \"0\");\n  }\n\n\n  function release(dir, boxPointX) {\n    if (!p.turnData.points) {\n      return;\n    }\n    if (p.turnData.lifting) {\n      p.turnData.releaseArgs = [dir, boxPointX];\n      return;\n    }\n    if (p.turnData.releasing) {\n      return;\n    }\n\n    checkPoint(boxPointX);\n\n    p.turnData.releasing = true;\n\n    if (dir == k.FORWARDS) {\n      if (\n        p.turnData.points.tap ||\n        p.turnData.points.start - boxPointX > 60 ||\n        p.turnData.points.min >= boxPointX\n      ) {\n        // Completing forward turn\n        slideOut(afterGoingForward);\n      } else {\n        // Cancelling forward turn\n        slideIn(afterCancellingForward);\n      }\n    } else if (dir == k.BACKWARDS) {\n      if (\n        p.turnData.points.tap ||\n        boxPointX - p.turnData.points.start > 60 ||\n        p.turnData.points.max <= boxPointX\n      ) {\n        // Completing backward turn\n        slideIn(afterGoingBackward);\n      } else {\n        // Cancelling backward turn\n        slideOut(afterCancellingBackward);\n      }\n    } else {\n      console.warn(\"Invalid direction: \" + dir);\n    }\n  }\n\n\n  function checkPoint(boxPointX) {\n    p.turnData.points.min = Math.min(p.turnData.points.min, boxPointX);\n    p.turnData.points.max = Math.max(p.turnData.points.max, boxPointX);\n    p.turnData.points.tap = p.turnData.points.max - p.turnData.points.min < 10;\n  }\n\n\n  function onGoingForward(x) {\n    lifted(x);\n  }\n\n\n  function onGoingBackward(x) {\n    var lp = lowerPage(), up = upperPage();\n\n    if (Monocle.Browser.env.offscreenRenderingClipped) {\n      // set lower to \"the page before upper\"\n      setPage(\n        lp,\n        getPlace(up).getLocus({ direction: k.BACKWARDS }),\n        function () {\n          // flip lower to upper, ready to slide in from left\n          flipPages();\n          // move lower off the screen to the left\n          jumpOut(lp, function () {\n            lifted(x);\n          });\n        }\n      );\n    } else {\n      jumpOut(lp, function () {\n        flipPages();\n        setPage(\n          lp,\n          getPlace(up).getLocus({ direction: k.BACKWARDS }),\n          function () { lifted(x); }\n        );\n      });\n    }\n  }\n\n\n  function afterGoingForward() {\n    var up = upperPage(), lp = lowerPage();\n    if (p.interactive) {\n      // set upper (off screen) to current\n      setPage(\n        up,\n        getPlace().getLocus({ direction: k.FORWARDS }),\n        function () {\n          // move upper back onto screen, then set lower to next and reset turn\n          jumpIn(up, function () { prepareNextPage(announceTurn); });\n        }\n      );\n    } else {\n      flipPages();\n      jumpIn(up, function () { prepareNextPage(announceTurn); });\n    }\n  }\n\n\n  function afterGoingBackward() {\n    if (p.interactive) {\n      // set lower page to current\n      setPage(\n        lowerPage(),\n        getPlace().getLocus(),\n        function () {\n          // flip lower to upper\n          flipPages();\n          // set lower to next and reset turn\n          prepareNextPage(announceTurn);\n        }\n      );\n    } else {\n      announceTurn();\n    }\n  }\n\n\n  function afterCancellingForward() {\n    announceCancel();\n  }\n\n\n  function afterCancellingBackward() {\n    flipPages(); // flip upper to lower\n    jumpIn(lowerPage(), function () { prepareNextPage(announceCancel); });\n  }\n\n\n  function prepareNextPage(callback) {\n    setPage(\n      lowerPage(),\n      getPlace().getLocus({ direction: k.FORWARDS }),\n      callback\n    );\n  }\n\n\n  function lifted(x) {\n    p.turnData.lifting = false;\n    p.reader.dispatchEvent('monocle:turning');\n    var releaseArgs = p.turnData.releaseArgs;\n    if (releaseArgs) {\n      p.turnData.releaseArgs = null;\n      release(releaseArgs[0], releaseArgs[1]);\n    } else if (x) {\n      slideToCursor(x);\n    }\n  }\n\n\n  function announceTurn() {\n    p.reader.dispatchEvent('monocle:turn');\n    resetTurnData();\n  }\n\n\n  function announceCancel() {\n    p.reader.dispatchEvent('monocle:turn:cancel');\n    resetTurnData();\n  }\n\n\n  function resetTurnData() {\n    hideWaitControl();\n    p.turnData = {};\n  }\n\n\n  function setX(elem, x, options, callback) {\n    var duration, transition;\n\n    if (!options.duration) {\n      duration = 0;\n    } else {\n      duration = parseInt(options.duration);\n    }\n\n    if (Monocle.Browser.env.supportsTransition) {\n      Monocle.Styles.transitionFor(\n        elem,\n        'transform',\n        duration,\n        options.timing,\n        options.delay\n      );\n\n      if (Monocle.Browser.env.supportsTransform3d) {\n        Monocle.Styles.affix(elem, 'transform', 'translate3d('+x+'px,0,0)');\n      } else {\n        Monocle.Styles.affix(elem, 'transform', 'translateX('+x+'px)');\n      }\n\n      if (typeof callback == \"function\") {\n        if (duration && Monocle.Styles.getX(elem) != x) {\n          Monocle.Events.afterTransition(elem, callback);\n        } else {\n          Monocle.defer(callback);\n        }\n      }\n    } else {\n      // Old-school JS animation.\n      elem.currX = elem.currX || 0;\n      var completeTransition = function () {\n        elem.currX = x;\n        Monocle.Styles.setX(elem, x);\n        if (typeof callback == \"function\") { callback(); }\n      }\n      if (!duration) {\n        completeTransition();\n      } else {\n        var stamp = (new Date()).getTime();\n        var frameRate = 40;\n        var step = (x - elem.currX) * (frameRate / duration);\n        var stepFn = function () {\n          var destX = elem.currX + step;\n          var timeElapsed = ((new Date()).getTime() - stamp) >= duration;\n          var pastDest = (destX > x && elem.currX < x) ||\n            (destX < x && elem.currX > x);\n          if (timeElapsed || pastDest) {\n            completeTransition();\n          } else {\n            Monocle.Styles.setX(elem, destX);\n            elem.currX = destX;\n            setTimeout(stepFn, frameRate);\n          }\n        }\n        stepFn();\n      }\n    }\n  }\n\n\n  function jumpIn(pageDiv, callback) {\n    opts = { duration: (Monocle.Browser.env.stickySlideOut ? 1 : 0) }\n    setX(pageDiv, 0, opts, callback);\n  }\n\n\n  function jumpOut(pageDiv, callback) {\n    setX(pageDiv, 0 - pageDiv.offsetWidth, { duration: 0 }, callback);\n  }\n\n\n  // NB: Slides are always done by the visible upper page.\n\n  function slideIn(callback) {\n    setX(upperPage(), 0, slideOpts(), callback);\n  }\n\n\n  function slideOut(callback) {\n    setX(upperPage(), 0 - upperPage().offsetWidth, slideOpts(), callback);\n  }\n\n\n  function slideToCursor(cursorX, callback, duration) {\n    setX(\n      upperPage(),\n      Math.min(0, cursorX - upperPage().offsetWidth),\n      { duration: duration || k.FOLLOW_DURATION },\n      callback\n    );\n  }\n\n\n  function slideOpts() {\n    var opts = { timing: 'ease-in', duration: 320 }\n    var now = (new Date()).getTime();\n    if (p.lastSlide && now - p.lastSlide < 1500) { opts.duration *= 0.5; }\n    p.lastSlide = now;\n    return opts;\n  }\n\n\n  function ensureWaitControl() {\n    if (p.waitControl) { return; }\n    p.waitControl = {\n      createControlElements: function (holder) {\n        return holder.dom.make('div', 'flippers_slider_wait');\n      }\n    }\n    p.reader.addControl(p.waitControl, 'page');\n  }\n\n\n  function showWaitControl() {\n    ensureWaitControl();\n    p.reader.dom.find('flippers_slider_wait', 0).style.opacity = 1;\n    p.reader.dom.find('flippers_slider_wait', 1).style.opacity = 1;\n  }\n\n\n  function hideWaitControl() {\n    ensureWaitControl();\n    p.reader.dom.find('flippers_slider_wait', 0).style.opacity = 0;\n    p.reader.dom.find('flippers_slider_wait', 1).style.opacity = 0;\n  }\n\n\n  // THIS IS THE CORE API THAT ALL FLIPPERS MUST PROVIDE.\n  API.pageCount = p.pageCount;\n  API.addPage = addPage;\n  API.getPlace = getPlace;\n  API.moveTo = moveTo;\n  API.listenForInteraction = listenForInteraction;\n\n  // OPTIONAL API - WILL BE INVOKED (WHERE RELEVANT) IF PROVIDED.\n  API.visiblePages = visiblePages;\n  API.interactiveMode = interactiveMode;\n\n  initialize();\n\n  return API;\n}\n\n\n// Constants\nMonocle.Flippers.Slider.DEFAULT_PANELS_CLASS = Monocle.Panels.TwoPane;\nMonocle.Flippers.Slider.FORWARDS = 1;\nMonocle.Flippers.Slider.BACKWARDS = -1;\nMonocle.Flippers.Slider.FOLLOW_DURATION = 100;\nMonocle.Flippers.Scroller = function (reader, setPageFn) {\n\n  var API = { constructor: Monocle.Flippers.Scroller }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    pageCount: 1,\n    duration: 300\n  }\n\n\n  function initialize() {\n    p.reader = reader;\n    p.setPageFn = setPageFn;\n  }\n\n\n  function addPage(pageDiv) {\n    pageDiv.m.dimensions = new Monocle.Dimensions.Columns(pageDiv);\n  }\n\n\n  function page() {\n    return p.reader.dom.find('page');\n  }\n\n\n  function listenForInteraction(panelClass) {\n    if (typeof panelClass != \"function\") {\n      panelClass = k.DEFAULT_PANELS_CLASS;\n    }\n    p.panels = new panelClass(\n      API,\n      {\n        'end': turn\n      }\n    );\n  }\n\n\n  function turn(dir) {\n    if (p.turning) { return; }\n    p.reader.selection.deselect();\n    moveTo({ page: getPlace().pageNumber() + dir});\n    p.reader.dispatchEvent('monocle:turning');\n  }\n\n\n  function getPlace() {\n    return page().m.place;\n  }\n\n\n  function moveTo(locus, callback) {\n    var fn = frameToLocus;\n    if (typeof callback == \"function\") {\n      fn = function (locus) { frameToLocus(locus); callback(locus); }\n    }\n    p.reader.getBook().setOrLoadPageAt(page(), locus, fn);\n  }\n\n\n  function frameToLocus(locus) {\n    if (locus.boundarystart || locus.boundaryend) { return; }\n    p.turning = true;\n    var dims = page().m.dimensions;\n    var fr = page().m.activeFrame;\n    var bdy = fr.contentDocument.body;\n    var anim = true;\n    if (p.activeComponent != fr.m.component) {\n      // No animation.\n      p.activeComponent = fr.m.component;\n      dims.translateToLocus(locus, \"none\");\n      Monocle.defer(turned);\n    } else if (Monocle.Browser.env.supportsTransition) {\n      // Native animation.\n      dims.translateToLocus(locus, p.duration+\"ms ease-in 0ms\");\n      Monocle.Events.afterTransition(bdy, turned);\n    } else {\n      // Old-school JS animation.\n      var x = dims.locusToOffset(locus);\n      var finalX = 0 - x;\n      var stamp = (new Date()).getTime();\n      var frameRate = 40;\n      var currX = p.currX || 0;\n      var step = (finalX - currX) * (frameRate / p.duration);\n      var stepFn = function () {\n        var destX = currX + step;\n        if (\n          (new Date()).getTime() - stamp > p.duration ||\n          Math.abs(currX - finalX) <= Math.abs((currX + step) - finalX)\n        ) {\n          Monocle.Styles.setX(bdy, finalX);\n          turned();\n        } else {\n          Monocle.Styles.setX(bdy, destX);\n          currX = destX;\n          setTimeout(stepFn, frameRate);\n        }\n        p.currX = destX;\n      }\n      stepFn();\n    }\n  }\n\n\n  function turned() {\n    p.turning = false;\n    p.reader.dispatchEvent('monocle:turn');\n  }\n\n\n  // THIS IS THE CORE API THAT ALL FLIPPERS MUST PROVIDE.\n  API.pageCount = p.pageCount;\n  API.addPage = addPage;\n  API.getPlace = getPlace;\n  API.moveTo = moveTo;\n  API.listenForInteraction = listenForInteraction;\n\n  initialize();\n\n  return API;\n}\n\nMonocle.Flippers.Scroller.speed = 200; // How long the animation takes\nMonocle.Flippers.Scroller.rate = 20; // frame-rate of the animation\nMonocle.Flippers.Scroller.FORWARDS = 1;\nMonocle.Flippers.Scroller.BACKWARDS = -1;\nMonocle.Flippers.Scroller.DEFAULT_PANELS_CLASS = Monocle.Panels.TwoPane;\nMonocle.Flippers.Instant = function (reader) {\n\n  var API = { constructor: Monocle.Flippers.Instant }\n  var k = API.constants = API.constructor;\n  var p = API.properties = {\n    pageCount: 1\n  }\n\n\n  function initialize() {\n    p.reader = reader;\n  }\n\n\n  function addPage(pageDiv) {\n    pageDiv.m.dimensions = new Monocle.Dimensions.Columns(pageDiv);\n  }\n\n\n  function getPlace() {\n    return page().m.place;\n  }\n\n\n  function moveTo(locus, callback) {\n    var fn = frameToLocus;\n    if (typeof callback == \"function\") {\n      fn = function (locus) { frameToLocus(locus); callback(locus); }\n    }\n    p.reader.getBook().setOrLoadPageAt(page(), locus, fn);\n  }\n\n\n  function listenForInteraction(panelClass) {\n    if (typeof panelClass != \"function\") {\n      if (Monocle.Browser.on.Kindle3) {\n        panelClass = Monocle.Panels.eInk;\n      }\n      panelClass = panelClass || k.DEFAULT_PANELS_CLASS;\n    }\n    if (!panelClass) { throw(\"Panels not found.\"); }\n    p.panels = new panelClass(API, { 'end': turn });\n  }\n\n\n  function page() {\n    return p.reader.dom.find('page');\n  }\n\n\n  function turn(dir) {\n    p.reader.selection.deselect();\n    moveTo({ page: getPlace().pageNumber() + dir});\n    p.reader.dispatchEvent('monocle:turning');\n  }\n\n\n  function frameToLocus(locus) {\n    page().m.dimensions.translateToLocus(locus);\n    Monocle.defer(function () { p.reader.dispatchEvent('monocle:turn'); });\n  }\n\n\n  // THIS IS THE CORE API THAT ALL FLIPPERS MUST PROVIDE.\n  API.pageCount = p.pageCount;\n  API.addPage = addPage;\n  API.getPlace = getPlace;\n  API.moveTo = moveTo;\n  API.listenForInteraction = listenForInteraction;\n\n  initialize();\n\n  return API;\n}\n\nMonocle.Flippers.Instant.FORWARDS = 1;\nMonocle.Flippers.Instant.BACKWARDS = -1;\nMonocle.Flippers.Instant.DEFAULT_PANELS_CLASS = Monocle.Panels.TwoPane;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]],"start1":0,"start2":0,"length1":0,"length2":153596}]],"length":153596}
{"contributors":[],"silentsave":false,"ts":1355882325831,"patch":[[{"diffs":[[0,") {\n        "],[1,"//"],[0,"API.billboar"]],"start1":53697,"start2":53697,"length1":24,"length2":26}]],"length":153598,"saved":false}
{"ts":1355883100208,"patch":[[{"diffs":[[0,"        "],[-1,"//"],[0,"API.bill"]],"start1":53701,"start2":53701,"length1":18,"length2":16},{"diffs":[[0,"how("],[-1,"k.SUPPORT_URL"],[1,"'https://www.google.ca'"],[0,", { "]],"start1":53724,"start2":53724,"length1":21,"length2":31}]],"length":153606,"saved":false}
{"ts":1355883394749,"patch":[[{"diffs":[[0,") {\n        "],[1,"//"],[0,"API.billboar"]],"start1":53697,"start2":53697,"length1":24,"length2":26}]],"length":153608,"saved":false}
