{"ts":1355613050940,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"(function(a){var b=function(c){this.blob=c};a.JSEpub=b;b.prototype={unzipperConstructor:JSUnzip,inflater:JSInflate,processInSteps:function(c){c(1);this.unzipBlob();this.files={};this.uncompressNextCompressedFile(c)},unzipBlob:function(){var c=new this.unzipperConstructor(this.blob);if(!c.isZipFile()){throw new Error(\"Invalid EPUB archive format.\")}c.readEntries();this.compressedFiles=c.entries},uncompressNextCompressedFile:function(d){var c=this;var e=this.compressedFiles.shift();if(e){d(2,e.fileName);this.uncompressFile(e);this.withTimeout(this.uncompressNextCompressedFile,d)}else{this.didUncompressAllFiles(d)}},withTimeout:function(e,d){var c=this;setTimeout(function(){e.call(c,d)},30)},didUncompressAllFiles:function(c){c(3);this.opfPath=this.getOpfPathFromContainer();this.readOpf(this.files[this.opfPath]);c(4);this.postProcess();c(5)},uncompressFiles:function(){this.files={};for(var d=0,c=this.entries.length;d<c;d++){this.uncompressFile(this.entries[d])}},uncompressFile:function(d){var c;if(d.compressionMethod===0){c=d.data}else{if(d.compressionMethod===8){c=this.inflater.inflate(d.data)}else{throw new Error(\"Unknown compression method \"+d.compressionMethod+\" encountered.\")}}if(d.fileName===\"META-INF/container.xml\"){this.container=c}else{if(d.fileName===\"mimetype\"){this.mimetype=c}else{this.files[d.fileName]=c}}},getOpfPathFromContainer:function(){var c=this.xmlDocument(this.container);return c.getElementsByTagName(\"rootfile\")[0].getAttribute(\"full-path\")},readOpf:function(j){var o=this.xmlDocument(j);var m={metadata:{},manifest:{},spine:[]};var l=o.getElementsByTagName(\"metadata\")[0].childNodes;for(var h=0,n=l.length;h<n;h++){var f=l[h];if(f.nodeType===3){continue}var p={};for(var g=0,c=f.attributes.length;g<c;g++){var k=f.attributes[g];p[k.name]=k.value}p._text=f.textContent;m.metadata[f.nodeName]=p}var d=o.getElementsByTagName(\"manifest\")[0].getElementsByTagName(\"item\");for(var h=0,n=d.length;h<n;h++){var f=d[h];m.manifest[f.getAttribute(\"id\")]={href:this.resolvePath(f.getAttribute(\"href\"),this.opfPath),\"media-type\":f.getAttribute(\"media-type\")}}var e=o.getElementsByTagName(\"spine\")[0].getElementsByTagName(\"itemref\");for(var h=0,n=e.length;h<n;h++){var f=e[h];m.spine.push(f.getAttribute(\"idref\"))}this.opf=m},resolvePath:function(g,c){var k=g.split(\"/\");var j=k.pop();var h=c.split(\"/\");h.pop();for(var f=0,e=k.length;f<e;f++){var d=k[f];if(d===\"..\"){h.pop()}else{h.push(d)}}h.push(j);return h.join(\"/\")},findMediaTypeByHref:function(c){for(key in this.opf.manifest){var e=this.opf.manifest[key];if(e.href===c){return e[\"media-type\"]}}var d=c.match(/\\.(\\w+)$/);return d&&\"image/\"+d[1]},postProcess:function(){for(var f in this.opf.manifest){var d=this.opf.manifest[f][\"media-type\"];var e=this.opf.manifest[f][\"href\"];var c;if(d===\"text/css\"){c=this.postProcessCSS(e)}else{if(d===\"application/xhtml+xml\"){c=this.postProcessHTML(e)}}if(c!==undefined){this.files[e]=c}}},postProcessCSS:function(d){var e=this.files[d];var c=this;e=e.replace(/url\\((.*?)\\)/gi,function(h,g){if(/^data/i.test(g)){return h}else{var f=c.getDataUri(g,d);return\"url(\"+f+\")\"}});return e},postProcessHTML:function(d){var h=decodeURIComponent(escape(this.files[d]));var o=this.xmlDocument(h);var k=o.getElementsByTagName(\"img\");for(var g=0,n=k.length;g<n;g++){var f=k[g];var c=f.getAttribute(\"src\");if(/^data/.test(c)){continue}f.setAttribute(\"src\",this.getDataUri(c,d))}var m=o.getElementsByTagName(\"head\")[0];var p=m.getElementsByTagName(\"link\");for(var g=0,n=p.length;g<n;g++){var l=p[0];if(l.getAttribute(\"type\")===\"text/css\"){var e=document.createElement(\"style\");e.setAttribute(\"type\",\"text/css\");e.setAttribute(\"data-orig-href\",l.getAttribute(\"href\"));var j=this.files[this.resolvePath(l.getAttribute(\"href\"),d)];e.appendChild(document.createTextNode(j));m.replaceChild(e,l)}}return o},getDataUri:function(f,d){var g=this.resolvePath(f,d);var c=this.findMediaTypeByHref(g);var e=escape(this.files[g]);return\"data:\"+c+\",\"+e},validate:function(){if(this.container===undefined){throw new Error(\"META-INF/container.xml file not found.\")}if(this.mimetype===undefined){throw new Error(\"Mimetype file not found.\")}if(this.mimetype!==\"application/epub+zip\"){throw new Error(\"Incorrect mimetype \"+this.mimetype)}},escapeData:function(c){return escape(c)},xmlDocument:function(c){var d=new DOMParser().parseFromString(c,\"text/xml\");if(d.childNodes[1]&&d.childNodes[1].nodeName===\"parsererror\"){throw d.childNodes[1].childNodes[0].nodeValue}return d}}}(this));"]],"start1":0,"start2":0,"length1":0,"length2":4471}]],"length":4471}
{"contributors":[],"silentsave":false,"ts":1355613075438,"patch":[[{"diffs":[[0,"tion"],[-1,"(a){var b=function(c){this.blob=c};a.JSEpub=b;b.prototype={unzipperConstructor:JSUnzip,inflater:JSInflate,processInSteps:function(c){c(1);this.unzipBlob();this.files={};this.uncompressNextCompressedFile(c)},unzipBlob:function(){var c=new this.unzipperConstructor(this.blob);if(!c.isZipFile()){throw new Error(\"Invalid EPUB archive format.\")}c.readEntries();this.compressedFiles=c.entries},uncompressNextCompressedFile:function(d){var c=this;var e=this.compressedFiles.shift();if(e){d(2,e.fileName);this.uncompressFile(e);this.withTimeout(this.uncompressNextCompressedFile,d)}else{this.didUncompressAllFiles(d)}},withTimeout:function(e,d){var c=this;setTimeout(function(){e.call(c,d)},30)},didUncompressAllFiles:function(c){c(3);this.opfPath=this.getOpfPathFromContainer();this.readOpf(this.files[this.opfPath]);c(4);this.postProcess();c(5)},uncompressFiles:function(){this.files={};for(var d=0,c=this.entries.length;d<c;d++){this.uncompressFile(this.entries[d])}},uncompressFile:function(d){var c;if(d.compressionMethod===0){c=d.data}else{if(d.compressionMethod===8){c=this.inflater.inflate(d.data)}else{throw new Error(\"Unknown compression method \"+d.compressionMethod+\" encountered.\")}}if(d.fileName===\"META-INF/container.xml\"){this.container=c}else{if(d.fileName===\"mimetype\"){this.mimetype=c}else{this.files[d.fileName]=c}}},getOpfPathFromContainer:function(){var c=this.xmlDocument(this.container);return c.getElementsByTagName(\"rootfile\")[0].getAttribute(\"full-path\")},readOpf:function(j){var o=this.xmlDocument(j);var m={metadata:{},manifest:{},spine:[]};var l=o.getElementsByTagName(\"metadata\")[0].childNodes;for(var h=0,n=l.length;h<n;h++){var f=l[h];if(f.nodeType===3){continue}var p={};for(var g=0,c=f.attributes.length;g<c;g++){var k=f.attributes[g];p[k.name]=k.value}p._text=f.textContent;m.metadata[f.nodeName]=p}var d=o.getElementsByTagName(\"manifest\")[0].getElementsByTagName(\"item\");for(var h=0,n=d.length;h<n;h++){var f=d[h];m.manifest[f.getAttribute(\"id\")]={href:this.resolvePath(f.getAttribute(\"href\"),this.opfPath),\"media-type\":f.getAttribute(\"media-type\")}}var e=o.getElementsByTagName(\"spine\")[0].getElementsByTagName(\"itemref\");for(var h=0,n=e.length;h<n;h++){var f=e[h];m.spine.push(f.getAttribute(\"idref\"))}this.opf=m},resolvePath:function(g,c){var k=g.split(\"/\");var j=k.pop();var h=c.split(\"/\");h.pop();for(var f=0,e=k.length;f<e;f++){var d=k[f];if(d===\"..\"){h.pop()}else{h.push(d)}}h.push(j);return h.join(\"/\")},findMediaTypeByHref:function(c){for(key in this.opf.manifest){var e=this.opf.manifest[key];if(e.href===c){return e[\"media-type\"]}}var d=c.match(/\\.(\\w+)$/);return d&&\"image/\"+d[1]},postProcess:function(){for(var f in this.opf.manifest){var d=this.opf.manifest[f][\"media-type\"];var e=this.opf.manifest[f][\"href\"];var c;if(d===\"text/css\"){c=this.postProcessCSS(e)}else{if(d===\"application/xhtml+xml\"){c=this.postProcessHTML(e)}}if(c!==undefined){this.files[e]=c}}},postProcessCSS:function(d){var e=this.files[d];var c=this;e=e.replace(/url\\((.*?)\\)/gi,function(h,g){if(/^data/i.test(g)){return h}else{var f=c.getDataUri(g,d);return\"url(\"+f+\")\"}});return e},postProcessHTML:function(d){var h=decodeURIComponent(escape(this.files[d]));var o=this.xmlDocument(h);var k=o.getElementsByTagName(\"img\");for(var g=0,n=k.length;g<n;g++){var f=k[g];var c=f.getAttribute(\"src\");if(/^data/.test(c)){continue}f.setAttribute(\"src\",this.getDataUri(c,d))}var m=o.getElementsByTagName(\"head\")[0];var p=m.getElementsByTagName(\"link\");for(var g=0,n=p.length;g<n;g++){var l=p[0];if(l.getAttribute(\"type\")===\"text/css\"){var e=document.createElement(\"style\");e.setAttribute(\"type\",\"text/css\");e.setAttribute(\"data-orig-href\",l.getAttribute(\"href\"));var j=this.files[this.resolvePath(l.getAttribute(\"href\"),d)];e.appendChild(document.createTextNode(j));m.replaceChild(e,l)}}return o},getDataUri:function(f,d){var g=this.resolvePath(f,d);var c=this.findMediaTypeByHref(g);var e=escape(this.files[g]);return\"data:\"+c+\",\"+e},validate:function(){if(this.container===undefined){throw new Error(\"META-INF/container.xml file not found.\")}if(this.mimetype===undefined){throw new Error(\"Mimetype file not found.\")}if(this.mimetype!==\"application/epub+zip\"){throw new Error(\"Incorrect mimetype \"+this.mimetype)}},escapeData:function(c){return escape(c)},xmlDocument:function(c){var d=new DOMParser().parseFromString(c,\"text/xml\");if(d.childNodes[1]&&d.childNodes[1].nodeName===\"parsererror\"){throw d.childNodes[1].childNodes[0].nodeValue}return d}}"],[1," (GLOBAL) {\r\n    var JSEpub = function (blob) {\r\n        this.blob = blob;\r\n    }\r\n\r\n    GLOBAL.JSEpub = JSEpub;\r\n\r\n    JSEpub.prototype = {\r\n        // For mockability\r\n        unzipper: function (blob) {\r\n            return new JSUnzip(blob);\r\n        },\r\n        inflate: function(blob) {\r\n            return JSInflate.inflate(blob);\r\n        },\r\n\r\n        // None-blocking processing of the EPUB. The notifier callback will\r\n        // get called with a number and a optional info parameter on various\r\n        // steps of the processing:\r\n        //\r\n        //  1: Unzipping\r\n        //  2: Uncompressing file. File name passed as 2nd argument.\r\n        //  3: Reading OPF\r\n        //  4: Post processing\r\n        //  5: Finished!\r\n        //\r\n        // Error codes:\r\n        //  -1: File is not a proper Zip file.\r\n        processInSteps: function (notifier) {\r\n            notifier(1);\r\n            if (this.unzipBlob(notifier) === false) {\r\n                return;\r\n            }\r\n\r\n            this.files = {};\r\n            this.uncompressNextCompressedFile(notifier);\r\n            // When all files are decompressed, uncompressNextCompressedFile\r\n            // will continue with the next step.\r\n        },\r\n\r\n        unzipBlob: function (notifier) {\r\n            var unzipper = this.unzipper(this.blob);\r\n            if (!unzipper.isZipFile()) {\r\n                notifier(-1);\r\n                return false;\r\n            }\r\n\r\n            unzipper.readEntries();\r\n            this.compressedFiles = unzipper.entries;\r\n        },\r\n\r\n        uncompressNextCompressedFile: function (notifier) {\r\n            var self = this;\r\n            var compressedFile = this.compressedFiles.shift();\r\n            if (compressedFile) {\r\n                notifier(2, compressedFile.fileName);\r\n                this.uncompressFile(compressedFile);\r\n                this.withTimeout(this.uncompressNextCompressedFile, notifier);\r\n            } else {\r\n                this.didUncompressAllFiles(notifier);\r\n            }\r\n        },\r\n        \r\n        // For mockability\r\n        withTimeout: function (func, notifier) {\r\n            var self = this;\r\n            setTimeout(function () {\r\n                func.call(self, notifier);\r\n            }, 30);\r\n        },\r\n\r\n        didUncompressAllFiles: function (notifier) {\r\n            notifier(3);\r\n            this.opfPath = this.getOpfPathFromContainer();\r\n            this.readOpf(this.files[this.opfPath]);\r\n\r\n            notifier(4);\r\n            this.postProcess();\r\n            notifier(5);\r\n        },\r\n\r\n        uncompressFile: function (compressedFile) {\r\n            var data;\r\n            if (compressedFile.compressionMethod === 0) {\r\n                data = compressedFile.data;\r\n            } else if (compressedFile.compressionMethod === 8) {\r\n                data = this.inflate(compressedFile.data);\r\n            } else {\r\n                throw new Error(\"Unknown compression method \"\r\n                                + compressedFile.compressionMethod \r\n                                + \" encountered.\");\r\n            }\r\n\r\n            if (compressedFile.fileName === \"META-INF/container.xml\") {\r\n                this.container = data;\r\n            } else if (compressedFile.fileName === \"mimetype\") {\r\n                this.mimetype = data;\r\n            } else {\r\n                this.files[compressedFile.fileName] = data;\r\n            }\r\n        },\r\n\r\n        getOpfPathFromContainer: function () {\r\n            var doc = this.xmlDocument(this.container);\r\n            return doc\r\n                .getElementsByTagName(\"rootfile\")[0]\r\n                .getAttribute(\"full-path\");\r\n        },\r\n\r\n        readOpf: function (xml) {\r\n            var doc = this.xmlDocument(xml);\r\n            \r\n            var opf = {\r\n                metadata: {},\r\n                manifest: {},\r\n                spine: []\r\n            };\r\n\r\n            var metadataNodes = doc\r\n                .getElementsByTagName(\"metadata\")[0]\r\n                .childNodes;\r\n\r\n            for (var i = 0, il = metadataNodes.length; i < il; i++) {\r\n                var node = metadataNodes[i];\r\n                // Skip text nodes (whitespace)\r\n                if (node.nodeType === 3) { continue }\r\n\r\n                var attrs = {};\r\n                for (var i2 = 0, il2 = node.attributes.length; i2 < il2; i2++) {\r\n                    var attr = node.attributes[i2];\r\n                    attrs[attr.name] = attr.value;\r\n                }\r\n                attrs._text = node.textContent;\r\n                opf.metadata[node.nodeName] = attrs;\r\n            }\r\n\r\n            var manifestEntries = doc\r\n                .getElementsByTagName(\"manifest\")[0]\r\n                .getElementsByTagName(\"item\");\r\n\r\n            for (var i = 0, il = manifestEntries.length; i < il; i++) {\r\n                var node = manifestEntries[i];\r\n\r\n                opf.manifest[node.getAttribute(\"id\")] = {\r\n                    \"href\": this.resolvePath(node.getAttribute(\"href\"), this.opfPath),\r\n                    \"media-type\": node.getAttribute(\"media-type\")\r\n                }\r\n            }\r\n\r\n            var spineEntries = doc\r\n                .getElementsByTagName(\"spine\")[0]\r\n                .getElementsByTagName(\"itemref\");\r\n\r\n            for (var i = 0, il = spineEntries.length; i < il; i++) {\r\n                var node = spineEntries[i];\r\n                opf.spine.push(node.getAttribute(\"idref\"));\r\n            }\r\n\r\n            this.opf = opf;\r\n        },\r\n\r\n        resolvePath: function (path, referrerLocation) {\r\n            var pathDirs = path.split(\"/\");\r\n            var fileName = pathDirs.pop();\r\n\r\n            var locationDirs = referrerLocation.split(\"/\");\r\n            locationDirs.pop();\r\n\r\n            for (var i = 0, il = pathDirs.length; i < il; i++) {\r\n                var spec = pathDirs[i];\r\n                if (spec === \"..\") {\r\n                    locationDirs.pop();\r\n                } else {\r\n                    locationDirs.push(spec);\r\n                }\r\n            }\r\n\r\n            locationDirs.push(fileName);\r\n            return locationDirs.join(\"/\");\r\n        },\r\n\r\n        findMediaTypeByHref: function (href) {\r\n            for (key in this.opf.manifest) {\r\n                var item = this.opf.manifest[key];\r\n                if (item[\"href\"] === href) {\r\n                    return item[\"media-type\"];\r\n                }\r\n            }\r\n\r\n            // Best guess if it's not in the manifest. (Those bastards.)\r\n            var match = href.match(/\\.(\\w+)$/);\r\n            return match && \"image/\" + match[1];\r\n        },\r\n\r\n        // Will modify all HTML and CSS files in place.\r\n        postProcess: function () {\r\n            for (var key in this.opf.manifest) {\r\n                var mediaType = this.opf.manifest[key][\"media-type\"]\r\n                var href = this.opf.manifest[key][\"href\"]\r\n                var result;\r\n\r\n                if (mediaType === \"text/css\") {\r\n                    result = this.postProcessCSS(href);\r\n                } else if (mediaType === \"application/xhtml+xml\") {\r\n                    result = this.postProcessHTML(href);\r\n                }\r\n\r\n                if (result !== undefined) {\r\n                    this.files[href] = result;\r\n                }\r\n            }\r\n        },\r\n\r\n        postProcessCSS: function (href) {\r\n            var file = this.files[href];\r\n            var self = this;\r\n\r\n            file = file.replace(/url\\((.*?)\\)/gi, function (str, url) {\r\n                if (/^data/i.test(url)) {\r\n                    // Don't replace data strings\r\n                    return str;\r\n                } else {\r\n                    var dataUri = self.getDataUri(url, href);\r\n                    return \"url(\" + dataUri + \")\";\r\n                }\r\n            });\r\n\r\n            return file;\r\n        },\r\n\r\n        postProcessHTML: function (href) {\r\n            var xml = decodeURIComponent(escape(this.files[href]));\r\n            var doc = this.xmlDocument(xml);\r\n\r\n            var images = doc.getElementsByTagName(\"img\");\r\n            for (var i = 0, il = images.length; i < il; i++) {\r\n                var image = images[i];\r\n                var src = image.getAttribute(\"src\");\r\n                if (/^data/.test(src)) { continue }\r\n                image.setAttribute(\"src\", this.getDataUri(src, href))\r\n            }\r\n\r\n            var head = doc.getElementsByTagName(\"head\")[0];\r\n            var links = head.getElementsByTagName(\"link\");\r\n            for (var i = 0, il = links.length; i < il; i++) {\r\n                var link = links[0];\r\n                if (link.getAttribute(\"type\") === \"text/css\") {\r\n                    var inlineStyle = document.createElement(\"style\");\r\n                    inlineStyle.setAttribute(\"type\", \"text/css\");\r\n                    inlineStyle.setAttribute(\"data-orig-href\", link.getAttribute(\"href\"));\r\n\r\n                    var css = this.files[this.resolvePath(link.getAttribute(\"href\"), href)];\r\n                    inlineStyle.appendChild(document.createTextNode(css));\r\n\r\n                    head.replaceChild(inlineStyle, link);\r\n                }\r\n            }\r\n\r\n            return doc;\r\n        },\r\n\r\n        getDataUri: function (url, href) {\r\n            var dataHref = this.resolvePath(url, href);\r\n            var mediaType = this.findMediaTypeByHref(dataHref);\r\n            var encodedData = escape(this.files[dataHref]);\r\n            return \"data:\" + mediaType + \",\" + encodedData;\r\n        },\r\n\r\n        validate: function () {\r\n            if (this.container === undefined) {\r\n                throw new Error(\"META-INF/container.xml file not found.\");\r\n            }\r\n\r\n            if (this.mimetype === undefined) {\r\n                throw new Error(\"Mimetype file not found.\");\r\n            }\r\n\r\n            if (this.mimetype !== \"application/epub+zip\") {\r\n                throw new Error(\"Incorrect mimetype \" + this.mimetype);\r\n            }\r\n        },\r\n\r\n        // for data URIs\r\n        escapeData: function (data) {\r\n            return escape(data);\r\n        },\r\n\r\n        xmlDocument: function (xml) {\r\n            var doc = new DOMParser().parseFromString(xml, \"text/xml\");\r\n\r\n            if (doc.childNodes[1] && doc.childNodes[1].nodeName === \"parsererror\") {\r\n                throw doc.childNodes[1].childNodes[0].nodeValue;\r\n            }\r\n\r\n            return doc;\r\n        }\r\n    }\r\n"],[0,"}(th"]],"start1":5,"start2":5,"length1":4461,"length2":10377}]],"length":10387,"saved":false}
